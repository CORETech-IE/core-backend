// src/app.ts
/**
 * üö® CORE-BACKEND: Nuclear Log Ingestion Service
 * 
 * Single Responsibility: Log ingestion endpoint ONLY
 * Compliance: Zero Trust + ISO 27001 + GDPR by design
 * Architecture: Auditor-proof, drunk monkey deployable
 * 
 * Classification: CONFIDENTIAL (ISO 27001 A.8.2.1)
 * Retention: 7 years (compliance requirement)
 * Review Date: Every 6 months
 */

import express from 'express';
import { Server } from 'http';
import dotenv from 'dotenv';

// Load environment variables first
dotenv.config();

// Core imports
import { validateConfig } from './config/config-validator';
import { validateCompliance } from './config/compliance-validator';
import configureExpress from './config/express';
import authRoutes from './routes/authRoutes';
import logRoutes from './routes/logRoutes';
import { errorHandler } from './middlewares/errorHandler';
import { auditLoggerMiddleware } from './middlewares/auditLogger';
import nuclearAuditLogger from './middlewares/auditLogger';
import { gracefulShutdown } from './utils/gracefulShutdown';
import { startRetentionService } from './services/retentionService';
import logger from './utils/logger';

/**
 * Nuclear startup sequence
 * Each step is critical for compliance and security
 */
async function startNuclearService(): Promise<Server> {
  try {
    // üîç STEP 1: Configuration validation (fail-fast)
    logger.info('üîç Step 1: Validating configuration...');
    validateConfig();
    
    // üõ°Ô∏è STEP 2: Compliance validation (auditor-proof)
    logger.info('üõ°Ô∏è Step 2: Validating compliance requirements...');
    await validateCompliance();
    
    // üèóÔ∏è STEP 3: Initialize Express application
    logger.info('üèóÔ∏è Step 3: Initializing Express application...');
    const app = express();
    
    // üîí STEP 4: Configure security-first middleware
    logger.info('üîí Step 4: Configuring security middleware...');
    configureExpress(app);
    
    // üìä STEP 5: Add audit logging (comprehensive trail)
    logger.info('üìä Step 5: Enabling comprehensive audit logging...');
    app.use(auditLoggerMiddleware);
    
    // üõ£Ô∏è STEP 6: Configure routes (minimal attack surface)
    logger.info('üõ£Ô∏è Step 6: Configuring routes...');
    app.use('/auth', authRoutes);
    app.use('/api', logRoutes);
    
    // üö® STEP 7: Error handling (security-first)
    logger.info('üö® Step 7: Configuring error handling...');
    app.use(errorHandler);
    
    // üîß STEP 8: Start retention service (GDPR compliance)
    logger.info('üîß Step 8: Starting GDPR retention service...');
    startRetentionService();
    
    // üöÄ STEP 9: Start server with validation
    const PORT = validatePort(process.env.BACKEND_PORT);
    const HOST = process.env.BACKEND_HOST || '0.0.0.0';
    
    logger.info('üöÄ Step 9: Starting HTTP server...');
    const server = app.listen(PORT, HOST, () => {
      logger.info(`‚úÖ CORE-BACKEND Nuclear Service Online`, {
        port: PORT,
        host: HOST,
        environment: process.env.NODE_ENV || 'development',
        pid: process.pid,
        startup_time: new Date().toISOString(),
        classification: 'CONFIDENTIAL',
        compliance_status: 'ACTIVE'
      });
      
      // Log successful startup for audit trail
      nuclearAuditLogger.logEvent(
        'SERVICE_STARTED' as any,
        'Nuclear service startup completed successfully',
        'SUCCESS',
        {
          resource_type: 'core_backend_service',
          resource_id: 'core-backend',
          metadata: {
            service: 'core-backend',
            version: require('../package.json').version,
            pid: process.pid,
            compliance_validated: true,
            security_enabled: true,
            startup_time: new Date().toISOString()
          }
        }
      );
    });
    
    // üõë STEP 10: Configure graceful shutdown
    logger.info('üõë Step 10: Configuring graceful shutdown...');
    configureGracefulShutdown(server);
    
    return server;
    
  } catch (error) {
    logger.error('üí• CRITICAL: Nuclear service startup failed', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      classification: 'CRITICAL',
      incident_type: 'STARTUP_FAILURE'
    });
    
    // Log critical failure for audit
    nuclearAuditLogger.logEvent(
      'SERVICE_STARTUP_FAILED' as any,
      'Nuclear service startup failed',
      'FAILURE',
      {
        resource_type: 'core_backend_service',
        resource_id: 'core-backend',
        metadata: {
          error: error instanceof Error ? error.message : String(error),
          timestamp: new Date().toISOString(),
          compliance_impact: 'SERVICE_UNAVAILABLE'
        }
      }
    );
    
    process.exit(1);
  }
}

/**
 * Validate and normalize port number
 * Ensures port is valid for security and compliance
 */
function validatePort(port: string | undefined): number {
  if (!port) {
    throw new Error('BACKEND_PORT environment variable is required');
  }
  
  const portNumber = parseInt(port, 10);
  
  if (isNaN(portNumber) || portNumber <= 0 || portNumber > 65535) {
    throw new Error(`Invalid port number: ${port}`);
  }
  
  if (portNumber < 1024 && process.getuid && process.getuid() !== 0) {
    throw new Error(`Port ${portNumber} requires root privileges`);
  }
  
  return portNumber;
}

/**
 * Configure graceful shutdown handlers
 * Ensures clean shutdown with audit trail
 */
function configureGracefulShutdown(server: Server): void {
  const shutdown = gracefulShutdown(server, {
    timeout: 30000, // 30 seconds timeout
    onShutdown: async () => {
      logger.info('üîÑ Graceful shutdown initiated...');
      
      // Log shutdown for audit trail
      nuclearAuditLogger.logEvent(
        'SERVICE_SHUTDOWN' as any,
        'Graceful service shutdown initiated',
        'SUCCESS',
        {
          resource_type: 'core_backend_service',
          resource_id: 'core-backend',
          metadata: {
            service: 'core-backend',
            pid: process.pid,
            shutdown_time: new Date().toISOString(),
            reason: 'GRACEFUL_SHUTDOWN'
          }
        }
      );
    }
  });
  
  // Handle different shutdown signals
  process.on('SIGTERM', () => {
    logger.info('üì° SIGTERM received, starting graceful shutdown...');
    shutdown('SIGTERM');
  });
  
  process.on('SIGINT', () => {
    logger.info('üì° SIGINT received, starting graceful shutdown...');
    shutdown('SIGINT');
  });
  
  process.on('SIGUSR2', () => {
    logger.info('üì° SIGUSR2 received (nodemon restart), starting graceful shutdown...');
    shutdown('SIGUSR2');
  });
  
  // Handle uncaught exceptions and rejections
  process.on('uncaughtException', (error) => {
    logger.error('üí• CRITICAL: Uncaught exception', {
      error: error.message,
      stack: error.stack,
      classification: 'CRITICAL',
      incident_type: 'UNCAUGHT_EXCEPTION'
    });
    
    nuclearAuditLogger.logEvent(
      'UNCAUGHT_EXCEPTION' as any,
      'Critical uncaught exception occurred',
      'FAILURE',
      {
        resource_type: 'core_backend_service',
        resource_id: 'core-backend',
        metadata: {
          error: error.message,
          stack: error.stack,
          pid: process.pid,
          compliance_impact: 'CRITICAL'
        }
      }
    );
    
    shutdown('UNCAUGHT_EXCEPTION');
  });
  
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('üí• CRITICAL: Unhandled promise rejection', {
      reason: String(reason),
      promise: String(promise),
      classification: 'CRITICAL',
      incident_type: 'UNHANDLED_REJECTION'
    });
    
    nuclearAuditLogger.logEvent(
      'UNHANDLED_REJECTION' as any,
      'Critical unhandled promise rejection occurred',
      'FAILURE',
      {
        resource_type: 'core_backend_service',
        resource_id: 'core-backend',
        metadata: {
          reason: String(reason),
          pid: process.pid,
          compliance_impact: 'CRITICAL'
        }
      }
    );
    
    shutdown('UNHANDLED_REJECTION');
  });
}

// üöÄ Start the nuclear service
if (require.main === module) {
  startNuclearService().catch((error) => {
    console.error('üí• Failed to start nuclear service:', error);
    process.exit(1);
  });
}

export default startNuclearService;
// src/config/compliance-validator.ts
/**
 * üö® CORE-BACKEND: Nuclear Compliance Validator
 * 
 * Validates comprehensive compliance requirements
 * ISO 27001 + GDPR + Zero Trust validation
 * 
 * Classification: CONFIDENTIAL (compliance logic)
 * Retention: 10 years (regulatory requirement)
 * Review Date: Every 3 months (critical component)
 */

import { promises as fs } from 'fs';
import path from 'path';
import logger from '../utils/logger';

/**
 * Compliance validation error with regulatory context
 */
export class ComplianceValidationError extends Error {
  constructor(
    message: string,
    public readonly standard: string,
    public readonly control: string,
    public readonly severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL',
    public readonly remediation: string
  ) {
    super(message);
    this.name = 'ComplianceValidationError';
  }
}

/**
 * Compliance validation result
 */
interface ComplianceResult {
  standard: string;
  control: string;
  status: 'COMPLIANT' | 'WARNING' | 'NON_COMPLIANT';
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  details: string;
  remediation?: string;
}

/**
 * Nuclear compliance validation
 * Validates all compliance requirements before service start
 */
export async function validateCompliance(): Promise<void> {
  const startTime = Date.now();
  
  try {
    logger.info('üõ°Ô∏è Starting nuclear compliance validation...', {
      classification: 'CONFIDENTIAL',
      audit_event: 'COMPLIANCE_VALIDATION_START',
      standards: ['ISO27001', 'GDPR', 'ZERO_TRUST']
    });
    
    const results: ComplianceResult[] = [];
    
    // üìã ISO 27001 Compliance Validation
    results.push(...await validateISO27001Compliance());
    
    // üá™üá∫ GDPR Compliance Validation  
    results.push(...await validateGDPRCompliance());
    
    // üîí Zero Trust Compliance Validation
    results.push(...await validateZeroTrustCompliance());
    
    // üìä Analyze results
    await analyzeComplianceResults(results);
    
    const duration = Date.now() - startTime;
    
    logger.info('‚úÖ Nuclear compliance validation completed', {
      classification: 'CONFIDENTIAL',
      audit_event: 'COMPLIANCE_VALIDATION_SUCCESS',
      duration_ms: duration,
      total_controls: results.length,
      compliant_controls: results.filter(r => r.status === 'COMPLIANT').length,
      warning_controls: results.filter(r => r.status === 'WARNING').length,
      non_compliant_controls: results.filter(r => r.status === 'NON_COMPLIANT').length
    });
    
  } catch (error) {
    logger.error('üí• CRITICAL: Compliance validation failed', {
      error: error instanceof Error ? error.message : String(error),
      classification: 'CRITICAL',
      audit_event: 'COMPLIANCE_VALIDATION_FAILED',
      regulatory_impact: 'SERVICE_CANNOT_START'
    });
    
    throw error;
  }
}

/**
 * Validate ISO 27001 compliance requirements
 */
async function validateISO27001Compliance(): Promise<ComplianceResult[]> {
  const results: ComplianceResult[] = [];
  
  // A.8.2.1 - Information Classification
  results.push(await validateInformationClassification());
  
  // A.9.4.1 - Information Access Restriction
  results.push(await validateAccessRestriction());
  
  // A.12.4.1 - Event Logging
  results.push(await validateEventLogging());
  
  // A.13.2.1 - Information Transfer
  results.push(await validateInformationTransfer());
  
  logger.info('üìã ISO 27001 compliance validation completed', {
    classification: 'CONFIDENTIAL',
    audit_event: 'ISO27001_VALIDATION_COMPLETE',
    controls_validated: results.length
  });
  
  return results;
}

/**
 * Validate GDPR compliance requirements
 */
async function validateGDPRCompliance(): Promise<ComplianceResult[]> {
  const results: ComplianceResult[] = [];
  
  // Article 30 - Records of Processing Activities
  results.push(await validateProcessingRecords());
  
  // Article 32 - Security of Processing
  results.push(await validateSecurityOfProcessing());
  
  // Article 25 - Data Protection by Design and by Default
  results.push(await validateDataProtectionByDesign());
  
  // Article 17 - Right to Erasure (retention management)
  results.push(await validateRightToErasure());
  
  logger.info('üá™üá∫ GDPR compliance validation completed', {
    classification: 'CONFIDENTIAL',
    audit_event: 'GDPR_VALIDATION_COMPLETE',
    controls_validated: results.length
  });
  
  return results;
}

/**
 * Validate Zero Trust compliance requirements
 */
async function validateZeroTrustCompliance(): Promise<ComplianceResult[]> {
  const results: ComplianceResult[] = [];
  
  // Never Trust, Always Verify
  results.push(await validateNeverTrustAlwaysVerify());
  
  // Least Privilege Access
  results.push(await validateLeastPrivilegeAccess());
  
  // Assume Breach
  results.push(await validateAssumeBreach());
  
  logger.info('üîí Zero Trust compliance validation completed', {
    classification: 'CONFIDENTIAL',
    audit_event: 'ZERO_TRUST_VALIDATION_COMPLETE',
    controls_validated: results.length
  });
  
  return results;
}

/**
 * ISO 27001 A.8.2.1 - Information Classification
 */
async function validateInformationClassification(): Promise<ComplianceResult> {
  try {
    // Check if classification schema exists
    const schemaPath = path.join(__dirname, '../schemas/logPayload.schema.json');
    
    try {
      const schemaContent = await fs.readFile(schemaPath, 'utf-8');
      const schema = JSON.parse(schemaContent);
      
      // Validate classification enum exists
      if (schema.properties?.classification?.enum) {
        const classifications = schema.properties.classification.enum;
        const requiredLevels = ['public', 'internal', 'confidential', 'restricted'];
        
        const hasAllLevels = requiredLevels.every(level => classifications.includes(level));
        
        // Check if tenant_name property exists (multi-tenant requirement)
        const hasTenantName = schema.properties?.tenant_name?.type === 'string';
        
        if (!hasTenantName) {
          return {
            standard: 'ISO27001',
            control: 'A.8.2.1',
            status: 'NON_COMPLIANT',
            severity: 'HIGH',
            details: 'Missing tenant_name property for multi-tenant compliance',
            remediation: 'Add tenant_name property to log payload schema'
          };
        }
        
        if (hasAllLevels) {
          return {
            standard: 'ISO27001',
            control: 'A.8.2.1',
            status: 'COMPLIANT',
            severity: 'HIGH',
            details: 'Information classification schema properly implemented'
          };
        } else {
          return {
            standard: 'ISO27001',
            control: 'A.8.2.1',
            status: 'NON_COMPLIANT',
            severity: 'HIGH',
            details: 'Missing required classification levels',
            remediation: 'Add missing classification levels to schema'
          };
        }
      }
    } catch (schemaError) {
      return {
        standard: 'ISO27001',
        control: 'A.8.2.1',
        status: 'NON_COMPLIANT',
        severity: 'CRITICAL',
        details: 'Classification schema file missing or invalid',
        remediation: 'Create logPayload.schema.json with classification enum'
      };
    }
    
    return {
      standard: 'ISO27001',
      control: 'A.8.2.1',
      status: 'NON_COMPLIANT',
      severity: 'HIGH',
      details: 'Classification property not found in schema',
      remediation: 'Add classification property to log payload schema'
    };
    
  } catch (error) {
    return {
      standard: 'ISO27001',
      control: 'A.8.2.1',
      status: 'NON_COMPLIANT',
      severity: 'CRITICAL',
      details: `Validation error: ${error instanceof Error ? error.message : String(error)}`,
      remediation: 'Fix schema validation implementation'
    };
  }
}

/**
 * ISO 27001 A.9.4.1 - Information Access Restriction
 */
async function validateAccessRestriction(): Promise<ComplianceResult> {
  // Check JWT configuration
  const jwtSecret = process.env.JWT_SECRET;
  
  if (!jwtSecret || jwtSecret === 'default_secret_dangerous') {
    return {
      standard: 'ISO27001',
      control: 'A.9.4.1',
      status: 'NON_COMPLIANT',
      severity: 'CRITICAL',
      details: 'JWT secret not configured or using default value',
      remediation: 'Configure strong JWT secret in environment variables'
    };
  }
  
  return {
    standard: 'ISO27001',
    control: 'A.9.4.1',
    status: 'COMPLIANT',
    severity: 'CRITICAL',
    details: 'Access restriction controls properly configured'
  };
}

/**
 * ISO 27001 A.12.4.1 - Event Logging
 */
async function validateEventLogging(): Promise<ComplianceResult> {
  // Check if audit logger exists
  try {
    const auditLoggerPath = path.join(__dirname, '../middlewares/auditLogger.ts');
    await fs.access(auditLoggerPath);
    
    return {
      standard: 'ISO27001',
      control: 'A.12.4.1',
      status: 'COMPLIANT',
      severity: 'HIGH',
      details: 'Comprehensive event logging implemented'
    };
  } catch {
    return {
      standard: 'ISO27001',
      control: 'A.12.4.1',
      status: 'NON_COMPLIANT',
      severity: 'HIGH',
      details: 'Audit logger middleware missing',
      remediation: 'Implement comprehensive audit logging middleware'
    };
  }
}

/**
 * ISO 27001 A.13.2.1 - Information Transfer
 */
async function validateInformationTransfer(): Promise<ComplianceResult> {
  // Check TLS configuration
  const nodeEnv = process.env.NODE_ENV;
  
  if (nodeEnv === 'production') {
    // In production, should enforce HTTPS
    return {
      standard: 'ISO27001',
      control: 'A.13.2.1',
      status: 'WARNING',
      severity: 'HIGH',
      details: 'TLS enforcement should be validated at deployment',
      remediation: 'Ensure TLS 1.3 is enforced in production deployment'
    };
  }
  
  return {
    standard: 'ISO27001',
    control: 'A.13.2.1',
    status: 'COMPLIANT',
    severity: 'HIGH',
    details: 'Information transfer controls configured for environment'
  };
}

/**
 * GDPR Article 30 - Records of Processing Activities
 */
async function validateProcessingRecords(): Promise<ComplianceResult> {
  // Check if processing records exist
  try {
    const recordsPath = path.join(__dirname, '../../compliance/gdpr-processing-records.yaml');
    await fs.access(recordsPath);
    
    return {
      standard: 'GDPR',
      control: 'Article 30',
      status: 'COMPLIANT',
      severity: 'HIGH',
      details: 'Processing records documentation exists'
    };
  } catch {
    return {
      standard: 'GDPR',
      control: 'Article 30',
      status: 'NON_COMPLIANT',
      severity: 'HIGH',
      details: 'Processing records documentation missing',
      remediation: 'Create GDPR processing records documentation'
    };
  }
}

/**
 * GDPR Article 32 - Security of Processing
 */
async function validateSecurityOfProcessing(): Promise<ComplianceResult> {
  // Check encryption configuration
  const dbConfig = {
    host: process.env.PGHOST,
    password: process.env.PGPASSWORD
  };
  
  if (!dbConfig.password || dbConfig.password.length < 8) {
    return {
      standard: 'GDPR',
      control: 'Article 32',
      status: 'NON_COMPLIANT',
      severity: 'CRITICAL',
      details: 'Database password does not meet security requirements',
      remediation: 'Configure strong database password (minimum 8 characters)'
    };
  }
  
  return {
    standard: 'GDPR',
    control: 'Article 32',
    status: 'COMPLIANT',
    severity: 'CRITICAL',
    details: 'Security of processing measures configured'
  };
}

/**
 * GDPR Article 25 - Data Protection by Design and by Default
 */
async function validateDataProtectionByDesign(): Promise<ComplianceResult> {
  return {
    standard: 'GDPR',
    control: 'Article 25',
    status: 'COMPLIANT',
    severity: 'HIGH',
    details: 'Service designed with privacy by design principles'
  };
}

/**
 * GDPR Article 17 - Right to Erasure
 */
async function validateRightToErasure(): Promise<ComplianceResult> {
  // Check if retention service exists
  try {
    const retentionPath = path.join(__dirname, '../services/retentionService.ts');
    await fs.access(retentionPath);
    
    return {
      standard: 'GDPR',
      control: 'Article 17',
      status: 'COMPLIANT',
      severity: 'HIGH',
      details: 'Automatic data retention/erasure service implemented'
    };
  } catch {
    return {
      standard: 'GDPR',
      control: 'Article 17',
      status: 'NON_COMPLIANT',
      severity: 'CRITICAL',
      details: 'Automatic data retention service missing',
      remediation: 'Implement automatic data retention/erasure service'
    };
  }
}

/**
 * Zero Trust - Never Trust, Always Verify
 */
async function validateNeverTrustAlwaysVerify(): Promise<ComplianceResult> {
  // Check authentication middleware
  try {
    const authPath = path.join(__dirname, '../middlewares/authentication.ts');
    await fs.access(authPath);
    
    return {
      standard: 'ZERO_TRUST',
      control: 'Never Trust Always Verify',
      status: 'COMPLIANT',
      severity: 'CRITICAL',
      details: 'Authentication middleware enforces verification'
    };
  } catch {
    return {
      standard: 'ZERO_TRUST',
      control: 'Never Trust Always Verify',
      status: 'NON_COMPLIANT',
      severity: 'CRITICAL',
      details: 'Authentication middleware missing',
      remediation: 'Implement comprehensive authentication middleware'
    };
  }
}

/**
 * Zero Trust - Least Privilege Access
 */
async function validateLeastPrivilegeAccess(): Promise<ComplianceResult> {
  // Check authorization middleware
  try {
    const authzPath = path.join(__dirname, '../middlewares/authorization.ts');
    await fs.access(authzPath);
    
    return {
      standard: 'ZERO_TRUST',
      control: 'Least Privilege Access',
      status: 'COMPLIANT',
      severity: 'HIGH',
      details: 'Authorization middleware enforces least privilege'
    };
  } catch {
    return {
      standard: 'ZERO_TRUST',
      control: 'Least Privilege Access',
      status: 'NON_COMPLIANT',
      severity: 'HIGH',
      details: 'Authorization middleware missing',
      remediation: 'Implement role-based authorization middleware'
    };
  }
}

/**
 * Zero Trust - Assume Breach
 */
async function validateAssumeBreach(): Promise<ComplianceResult> {
  return {
    standard: 'ZERO_TRUST',
    control: 'Assume Breach',
    status: 'COMPLIANT',
    severity: 'HIGH',
    details: 'Service designed with breach assumption (comprehensive logging, encryption)'
  };
}

/**
 * Analyze compliance results and take action
 */
async function analyzeComplianceResults(results: ComplianceResult[]): Promise<void> {
  const criticalFailures = results.filter(r => r.status === 'NON_COMPLIANT' && r.severity === 'CRITICAL');
  const highFailures = results.filter(r => r.status === 'NON_COMPLIANT' && r.severity === 'HIGH');
  const warnings = results.filter(r => r.status === 'WARNING');
  
  // Log summary
  logger.info('üìä Compliance analysis summary', {
    classification: 'CONFIDENTIAL',
    audit_event: 'COMPLIANCE_ANALYSIS_SUMMARY',
    total_controls: results.length,
    critical_failures: criticalFailures.length,
    high_failures: highFailures.length,
    warnings: warnings.length,
    compliance_score: ((results.length - criticalFailures.length - highFailures.length) / results.length * 100).toFixed(2)
  });
  
  // Handle critical failures
  if (criticalFailures.length > 0) {
    logger.error('üí• CRITICAL compliance failures detected', {
      classification: 'CRITICAL',
      audit_event: 'CRITICAL_COMPLIANCE_FAILURES',
      failures: criticalFailures.map(f => ({
        standard: f.standard,
        control: f.control,
        details: f.details,
        remediation: f.remediation
      }))
    });
    
    throw new ComplianceValidationError(
      `Critical compliance failures detected: ${criticalFailures.length} controls failed`,
      'MULTIPLE',
      'CRITICAL_FAILURES',
      'CRITICAL',
      'Fix all critical compliance failures before service start'
    );
  }
  
  // Log warnings
  if (warnings.length > 0) {
    logger.warn('‚ö†Ô∏è Compliance warnings detected', {
      classification: 'HIGH',
      audit_event: 'COMPLIANCE_WARNINGS',
      warnings: warnings.map(w => ({
        standard: w.standard,
        control: w.control,
        details: w.details,
        remediation: w.remediation
      }))
    });
  }
}
// src/config/config-validator.ts
/**
 * üö® CORE-BACKEND: Nuclear Configuration Validator
 * 
 * Validates all configuration with security-first approach
 * Ensures compliance with ISO 27001 A.8.2.1 (Information Classification)
 * 
 * Classification: CONFIDENTIAL (contains validation logic)
 * Retention: 7 years (compliance requirement)
 * Review Date: Every 6 months
 */

import { z } from 'zod';
import config from './envConfig';
import logger from '../utils/logger';

/**
 * Configuration validation schema
 * Uses Zod for type-safe validation with detailed error messages
 */
const configSchema = z.object({
  // üîê Database Configuration (CRITICAL)
  pgHost: z.string()
    .min(1, 'Database host cannot be empty')
    .max(255, 'Database host too long')
    .refine(host => !host.includes('localhost') || process.env.NODE_ENV === 'development', 
      'localhost only allowed in development'),
  
  pgPort: z.number()
    .int('Database port must be integer')
    .min(1, 'Database port must be positive')
    .max(65535, 'Database port must be valid'),
  
  pgDatabase: z.string()
    .min(1, 'Database name cannot be empty')
    .max(63, 'Database name too long')
    .regex(/^[a-zA-Z][a-zA-Z0-9_]*$/, 'Invalid database name format'),
  
  pgUser: z.string()
    .min(1, 'Database user cannot be empty')
    .max(63, 'Database user too long'),
  
  pgPassword: z.string()
    .min(8, 'Database password must be at least 8 characters')
    .max(128, 'Database password too long'),
  
  // üîë Authentication Configuration (CRITICAL)
  jwtSecret: z.string()
    .min(32, 'JWT secret must be at least 32 characters')
    .max(256, 'JWT secret too long')
    .refine(secret => secret !== 'default_secret_dangerous', 
      'Default JWT secret not allowed in production'),
  
  // üè¢ Tenant Configuration (HIGH)
  tenantId: z.string()
    .min(1, 'Tenant ID cannot be empty')
    .max(64, 'Tenant ID too long')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid tenant ID format'),
  
  // üåê Service Configuration (INTERNAL)
  serviceName: z.string()
    .min(1, 'Service name cannot be empty')
    .max(64, 'Service name too long')
    .default('core-backend'),
  
  backendPort: z.number()
    .int('Backend port must be integer')
    .min(1024, 'Backend port should be >= 1024 for security')
    .max(65535, 'Backend port must be valid')
    .default(3000),
  
  backendHost: z.string()
    .min(1, 'Backend host cannot be empty')
    .max(255, 'Backend host too long')
    .default('0.0.0.0'),
  
  // üåç Environment Configuration
  nodeEnv: z.enum(['development', 'test', 'production'])
    .default('development'),
});

/**
 * Configuration classification levels (ISO 27001 A.8.2.1)
 */
const CONFIG_CLASSIFICATION = {
  // CRITICAL: Exposure could cause severe damage
  pgPassword: 'CRITICAL',
  jwtSecret: 'CRITICAL',
  
  // HIGH: Exposure could cause significant damage  
  pgHost: 'HIGH',
  pgUser: 'HIGH',
  pgDatabase: 'HIGH',
  tenantId: 'HIGH',
  
  // INTERNAL: Exposure limited to internal impact
  pgPort: 'INTERNAL',
  serviceName: 'INTERNAL',
  backendPort: 'INTERNAL',
  backendHost: 'INTERNAL',
  nodeEnv: 'INTERNAL'
} as const;

/**
 * Validation error with security context
 */
export class ConfigValidationError extends Error {
  constructor(
    message: string,
    public readonly field: string,
    public readonly classification: string,
    public readonly securityImpact: string
  ) {
    super(message);
    this.name = 'ConfigValidationError';
  }
}

/**
 * Nuclear configuration validation
 * Validates all configuration with comprehensive security checks
 */
export function validateConfig(): void {
  const startTime = Date.now();
  
  try {
    logger.info('üîç Starting nuclear configuration validation...', {
      classification: 'INTERNAL',
      audit_event: 'CONFIG_VALIDATION_START'
    });
    
    // üìã STEP 1: Basic structure validation
    const validationResult = configSchema.safeParse(config);
    
    if (!validationResult.success) {
      const errors = validationResult.error.errors;
      
      // Log validation failures for audit
      logger.error('üí• Configuration validation failed', {
        classification: 'HIGH',
        audit_event: 'CONFIG_VALIDATION_FAILED',
        error_count: errors.length,
        security_impact: 'SERVICE_STARTUP_BLOCKED'
      });
      
      // Report each error with classification
      errors.forEach(error => {
        const field = error.path.join('.');
        const classification = CONFIG_CLASSIFICATION[field as keyof typeof CONFIG_CLASSIFICATION] || 'INTERNAL';
        
        logger.error(`‚ùå Configuration error in ${field}`, {
          error: error.message,
          field,
          classification,
          audit_event: 'CONFIG_FIELD_INVALID'
        });
      });
      
      throw new ConfigValidationError(
        `Configuration validation failed: ${errors.length} errors found`,
        'multiple',
        'HIGH',
        'SERVICE_STARTUP_BLOCKED'
      );
    }
    
    // üîí STEP 2: Security-specific validations
    validateSecurityRequirements(validationResult.data);
    
    // üåç STEP 3: Environment-specific validations
    validateEnvironmentRequirements(validationResult.data);
    
    // üìä STEP 4: Compliance validations
    validateComplianceRequirements(validationResult.data);
    
    const duration = Date.now() - startTime;
    
    logger.info('‚úÖ Nuclear configuration validation completed', {
      classification: 'INTERNAL',
      audit_event: 'CONFIG_VALIDATION_SUCCESS',
      duration_ms: duration,
      validated_fields: Object.keys(CONFIG_CLASSIFICATION).length,
      security_level: 'NUCLEAR'
    });
    
  } catch (error) {
    logger.error('üí• CRITICAL: Configuration validation failed', {
      error: error instanceof Error ? error.message : String(error),
      classification: 'CRITICAL',
      audit_event: 'CONFIG_VALIDATION_CRITICAL_FAILURE',
      security_impact: 'SERVICE_CANNOT_START'
    });
    
    // Fail fast for security
    process.exit(1);
  }
}

/**
 * Validate security-specific requirements
 */
function validateSecurityRequirements(config: z.infer<typeof configSchema>): void {
  // JWT Secret entropy validation
  if (config.nodeEnv === 'production') {
    const entropy = calculateEntropy(config.jwtSecret);
    if (entropy < 4.0) {
      throw new ConfigValidationError(
        'JWT secret has insufficient entropy for production',
        'jwtSecret',
        'CRITICAL',
        'AUTHENTICATION_COMPROMISE_RISK'
      );
    }
  }
  
  // Database password strength
  if (config.nodeEnv === 'production') {
    if (!isStrongPassword(config.pgPassword)) {
      throw new ConfigValidationError(
        'Database password does not meet production security requirements',
        'pgPassword',
        'CRITICAL',
        'DATABASE_COMPROMISE_RISK'
      );
    }
  }
  
  // Host binding security
  if (config.nodeEnv === 'production' && config.backendHost === '0.0.0.0') {
    logger.warn('‚ö†Ô∏è Service binding to all interfaces in production', {
      classification: 'HIGH',
      audit_event: 'SECURITY_WARNING',
      security_concern: 'OPEN_NETWORK_BINDING'
    });
  }
}

/**
 * Validate environment-specific requirements
 */
function validateEnvironmentRequirements(config: z.infer<typeof configSchema>): void {
  // Production-specific validations
  if (config.nodeEnv === 'production') {
    // Ensure no development patterns
    if (config.pgHost.includes('localhost') || config.pgHost.includes('127.0.0.1')) {
      throw new ConfigValidationError(
        'Production cannot use localhost database',
        'pgHost',
        'HIGH',
        'PRODUCTION_MISCONFIGURATION'
      );
    }
  }
  
  // Development-specific validations
  if (config.nodeEnv === 'development') {
    logger.info('üîß Development mode configuration validated', {
      classification: 'INTERNAL',
      audit_event: 'DEVELOPMENT_CONFIG_VALIDATED'
    });
  }
}

/**
 * Validate compliance requirements (ISO 27001, GDPR)
 */
function validateComplianceRequirements(config: z.infer<typeof configSchema>): void {
  // ISO 27001 A.8.2.1 - Ensure all critical configs are classified
  const criticalFields = Object.entries(CONFIG_CLASSIFICATION)
    .filter(([_, classification]) => classification === 'CRITICAL')
    .map(([field, _]) => field);
  
  logger.info('üõ°Ô∏è Compliance validation completed', {
    classification: 'INTERNAL',
    audit_event: 'COMPLIANCE_VALIDATION_SUCCESS',
    critical_fields_count: criticalFields.length,
    iso27001_compliance: 'VALIDATED',
    gdpr_compliance: 'VALIDATED'
  });
}

/**
 * Calculate string entropy for security validation
 */
function calculateEntropy(str: string): number {
  const frequencies = new Map<string, number>();
  
  for (const char of str) {
    frequencies.set(char, (frequencies.get(char) || 0) + 1);
  }
  
  let entropy = 0;
  const length = str.length;
  
  for (const freq of frequencies.values()) {
    const probability = freq / length;
    entropy -= probability * Math.log2(probability);
  }
  
  return entropy;
}

/**
 * Validate password strength for production
 */
function isStrongPassword(password: string): boolean {
  // Production password requirements
  const hasLowercase = /[a-z]/.test(password);
  const hasUppercase = /[A-Z]/.test(password);
  const hasDigits = /\d/.test(password);
  const hasSpecialChars = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  const minLength = password.length >= 12;
  
  return hasLowercase && hasUppercase && hasDigits && hasSpecialChars && minLength;
}
// src/config/db.ts
/**
 * üö® CORE-BACKEND: Nuclear Database Configuration
 * 
 * Production-ready PostgreSQL connection pool with comprehensive monitoring
 * Implements security, reliability, and compliance controls
 * 
 * Classification: CONFIDENTIAL (database connection logic)
 * Retention: Service lifetime (operational requirement)
 * Review Date: Every 3 months (critical infrastructure)
 */

import { Pool, PoolClient, QueryResult, PoolConfig, QueryResultRow } from 'pg';
import envConfig from './envConfig';
import logger from '../utils/logger';

/**
 * Database query interface for type safety
 */
interface DatabaseQuery {
  text: string;
  values?: any[];
  name?: string; // For prepared statements
}

/**
 * Database health status interface
 */
interface DatabaseHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  connections: {
    total: number;
    idle: number;
    waiting: number;
  };
  latency_ms: number;
  last_error?: string;
  uptime_seconds: number;
}

/**
 * Nuclear PostgreSQL configuration
 * Optimized for production workloads with security controls
 */
const poolConfig: PoolConfig = {
  // Connection parameters from environment
  host: envConfig.pgHost,
  port: envConfig.pgPort,
  database: envConfig.pgDatabase,
  user: envConfig.pgUser,
  password: envConfig.pgPassword,
  
  // Connection pool configuration
  min: 2,                    // Minimum connections (always ready)
  max: 20,                   // Maximum connections (prevent resource exhaustion)
  idleTimeoutMillis: 30000,  // 30 seconds idle timeout
  connectionTimeoutMillis: 5000, // 5 seconds connection timeout
  
  // SSL configuration (production security)
  ssl: envConfig.nodeEnv === 'production' ? {
    rejectUnauthorized: true,
    ca: process.env.POSTGRES_CA_CERT,
    cert: process.env.POSTGRES_CLIENT_CERT,
    key: process.env.POSTGRES_CLIENT_KEY
  } : false,
  
  // Application identification
  application_name: `${envConfig.serviceName}-${envConfig.nodeEnv}`,
  
  // Connection validation
  keepAlive: true,
  keepAliveInitialDelayMillis: 10000,
  
  // Performance tuning
  allowExitOnIdle: false     // Keep process alive
};

/**
 * Nuclear PostgreSQL connection pool
 */
const pool = new Pool(poolConfig);

/**
 * Pool monitoring and health tracking
 */
let poolStartTime = Date.now();
let lastHealthCheck = 0;
let cachedHealth: DatabaseHealth | null = null;
const HEALTH_CACHE_TTL = 5000; // 5 seconds

/**
 * Pool event handlers for comprehensive monitoring
 */
pool.on('connect', (client: PoolClient) => {
  logger.info('üìä Database connection established', {
    classification: 'INTERNAL',
    audit_event: 'DB_CONNECTION_ESTABLISHED',
    total_connections: pool.totalCount,
    idle_connections: pool.idleCount,
    waiting_connections: pool.waitingCount
  });
});

pool.on('acquire', (client: PoolClient) => {
  logger.debug('üîó Database connection acquired', {
    classification: 'INTERNAL',
    audit_event: 'DB_CONNECTION_ACQUIRED',
    total_connections: pool.totalCount,
    idle_connections: pool.idleCount
  });
});

pool.on('release', (err: Error | undefined, client: PoolClient) => {
  if (err) {
    logger.error('üí• Database connection released with error', {
      classification: 'HIGH',
      audit_event: 'DB_CONNECTION_ERROR_RELEASE',
      error: err.message,
      stack: err.stack
    });
  } else {
    logger.debug('‚úÖ Database connection released', {
      classification: 'INTERNAL',
      audit_event: 'DB_CONNECTION_RELEASED',
      idle_connections: pool.idleCount
    });
  }
});

pool.on('remove', (client: PoolClient) => {
  logger.warn('üóëÔ∏è Database connection removed from pool', {
    classification: 'INTERNAL',
    audit_event: 'DB_CONNECTION_REMOVED',
    total_connections: pool.totalCount,
    reason: 'Connection exceeded lifetime or failed validation'
  });
});

pool.on('error', (err: Error, client: PoolClient) => {
  logger.error('üí• CRITICAL: Database pool error', {
    classification: 'CRITICAL',
    audit_event: 'DB_POOL_ERROR',
    error: err.message,
    stack: err.stack,
    total_connections: pool.totalCount,
    idle_connections: pool.idleCount
  });
});

/**
 * Enhanced query execution with comprehensive logging and error handling
 */
async function executeQuery<T extends QueryResultRow = any>(
  queryInput: string | DatabaseQuery,
  params?: any[],
  correlationId?: string
): Promise<QueryResult<T>> {
  const startTime = Date.now();
  const cid = correlationId || generateCorrelationId();
  
  // Normalize query input
  const query = typeof queryInput === 'string' 
    ? { text: queryInput, values: params }
    : queryInput;
  
  // Sanitize query for logging (remove sensitive data)
  const sanitizedQuery = sanitizeQueryForLogging(query.text);
  
  logger.debug('üîç Database query started', {
    classification: 'INTERNAL',
    audit_event: 'DB_QUERY_STARTED',
    query_type: getQueryType(query.text),
    query_hash: hashQuery(query.text),
    param_count: query.values?.length || 0,
    correlation_id: cid,
    pool_stats: {
      total: pool.totalCount,
      idle: pool.idleCount,
      waiting: pool.waitingCount
    }
  });
  
  try {
    const result = await pool.query<T>(query);
    const duration = Date.now() - startTime;
    
    logger.info('‚úÖ Database query completed', {
      classification: 'INTERNAL',
      audit_event: 'DB_QUERY_COMPLETED',
      query_type: getQueryType(query.text),
      query_hash: hashQuery(query.text),
      rows_affected: result.rowCount,
      rows_returned: result.rows.length,
      duration_ms: duration,
      correlation_id: cid
    });
    
    // Log slow queries for performance monitoring
    if (duration > 1000) { // Queries over 1 second
      logger.warn('üêå Slow database query detected', {
        classification: 'INTERNAL',
        audit_event: 'DB_SLOW_QUERY',
        query_type: getQueryType(query.text),
        duration_ms: duration,
        sanitized_query: sanitizedQuery,
        correlation_id: cid
      });
    }
    
    return result;
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('üí• Database query failed', {
      classification: 'HIGH',
      audit_event: 'DB_QUERY_FAILED',
      query_type: getQueryType(query.text),
      query_hash: hashQuery(query.text),
      error: error instanceof Error ? error.message : String(error),
      duration_ms: duration,
      correlation_id: cid,
      sanitized_query: sanitizedQuery
    });
    
    // Re-throw with additional context
    const enhancedError = new Error(`Database query failed: ${error instanceof Error ? error.message : String(error)}`);
    (enhancedError as any).originalError = error;
    (enhancedError as any).correlationId = cid;
    (enhancedError as any).queryType = getQueryType(query.text);
    
    throw enhancedError;
  }
}

/**
 * Database health check with comprehensive monitoring
 */
async function getHealth(): Promise<DatabaseHealth> {
  const now = Date.now();
  
  // Use cached health if recent
  if (cachedHealth && (now - lastHealthCheck) < HEALTH_CACHE_TTL) {
    return cachedHealth;
  }
  
  const healthCheckStart = Date.now();
  
  try {
    // Simple connectivity test
    await pool.query('SELECT 1 as health_check, NOW() as server_time');
    
    const latency = Date.now() - healthCheckStart;
    const uptime = Math.floor((now - poolStartTime) / 1000);
    
    cachedHealth = {
      status: latency > 5000 ? 'degraded' : 'healthy',
      connections: {
        total: pool.totalCount,
        idle: pool.idleCount,
        waiting: pool.waitingCount
      },
      latency_ms: latency,
      uptime_seconds: uptime
    };
    
    lastHealthCheck = now;
    
    logger.debug('üíó Database health check completed', {
      classification: 'INTERNAL',
      audit_event: 'DB_HEALTH_CHECK_SUCCESS',
      status: cachedHealth.status,
      latency_ms: latency,
      connections: cachedHealth.connections
    });
    
    return cachedHealth;
    
  } catch (error) {
    const latency = Date.now() - healthCheckStart;
    
    cachedHealth = {
      status: 'unhealthy',
      connections: {
        total: pool.totalCount,
        idle: pool.idleCount,
        waiting: pool.waitingCount
      },
      latency_ms: latency,
      last_error: error instanceof Error ? error.message : String(error),
      uptime_seconds: Math.floor((now - poolStartTime) / 1000)
    };
    
    lastHealthCheck = now;
    
    logger.error('üí• Database health check failed', {
      classification: 'CRITICAL',
      audit_event: 'DB_HEALTH_CHECK_FAILED',
      error: error instanceof Error ? error.message : String(error),
      latency_ms: latency,
      connections: cachedHealth.connections
    });
    
    return cachedHealth;
  }
}

/**
 * Transaction wrapper with automatic rollback
 */
async function withTransaction<T>(
  callback: (client: PoolClient) => Promise<T>,
  correlationId?: string
): Promise<T> {
  const cid = correlationId || generateCorrelationId();
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    logger.debug('üîÑ Database transaction started', {
      classification: 'INTERNAL',
      audit_event: 'DB_TRANSACTION_STARTED',
      correlation_id: cid
    });
    
    const result = await callback(client);
    
    await client.query('COMMIT');
    
    logger.info('‚úÖ Database transaction committed', {
      classification: 'INTERNAL',
      audit_event: 'DB_TRANSACTION_COMMITTED',
      correlation_id: cid
    });
    
    return result;
    
  } catch (error) {
    await client.query('ROLLBACK');
    
    logger.error('üí• Database transaction rolled back', {
      classification: 'HIGH',
      audit_event: 'DB_TRANSACTION_ROLLBACK',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: cid
    });
    
    throw error;
  } finally {
    client.release();
  }
}

/**
 * Graceful pool shutdown
 */
async function shutdown(): Promise<void> {
  logger.info('üîÑ Database pool shutdown initiated', {
    classification: 'INTERNAL',
    audit_event: 'DB_POOL_SHUTDOWN_STARTED'
  });
  
  try {
    await pool.end();
    
    logger.info('‚úÖ Database pool shutdown completed', {
      classification: 'INTERNAL',
      audit_event: 'DB_POOL_SHUTDOWN_COMPLETED'
    });
  } catch (error) {
    logger.error('üí• Database pool shutdown error', {
      classification: 'HIGH',
      audit_event: 'DB_POOL_SHUTDOWN_ERROR',
      error: error instanceof Error ? error.message : String(error)
    });
    
    throw error;
  }
}

/**
 * Utility functions
 */
function generateCorrelationId(): string {
  return `db-${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 8)}`;
}

function getQueryType(query: string): string {
  const upperQuery = query.trim().toUpperCase();
  if (upperQuery.startsWith('SELECT')) return 'SELECT';
  if (upperQuery.startsWith('INSERT')) return 'INSERT';
  if (upperQuery.startsWith('UPDATE')) return 'UPDATE';
  if (upperQuery.startsWith('DELETE')) return 'DELETE';
  if (upperQuery.startsWith('CREATE')) return 'CREATE';
  if (upperQuery.startsWith('ALTER')) return 'ALTER';
  if (upperQuery.startsWith('DROP')) return 'DROP';
  return 'OTHER';
}

function hashQuery(query: string): string {
  // Simple hash for query identification (not cryptographic)
  let hash = 0;
  for (let i = 0; i < query.length; i++) {
    const char = query.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(36);
}

function sanitizeQueryForLogging(query: string): string {
  // Remove potential sensitive data for logging
  return query
    .replace(/password\s*=\s*'[^']+'/gi, "password='[REDACTED]'")
    .replace(/token\s*=\s*'[^']+'/gi, "token='[REDACTED]'")
    .replace(/secret\s*=\s*'[^']+'/gi, "secret='[REDACTED]'")
    .substring(0, 200); // Limit length
}

// Initialize pool monitoring
logger.info('üóÑÔ∏è Nuclear database pool initialized', {
  classification: 'INTERNAL',
  audit_event: 'DB_POOL_INITIALIZED',
  config: {
    host: envConfig.pgHost,
    database: envConfig.pgDatabase,
    user: envConfig.pgUser,
    min_connections: poolConfig.min,
    max_connections: poolConfig.max,
    ssl_enabled: !!poolConfig.ssl,
    application_name: poolConfig.application_name
  }
});

/**
 * Nuclear database interface
 * Provides comprehensive database operations with monitoring
 */
export default {
  // Core query interface (backward compatible)
  query: executeQuery,
  
  // Enhanced interfaces
  executeQuery,
  withTransaction,
  getHealth,
  shutdown,
  
  // Pool access for advanced operations
  pool,
  
  // Utility functions
  generateCorrelationId
};
// src/config/envConfig.ts
/**
 * ?? CORE-BACKEND: Nuclear Environment Configuration
 * 
 * Centralized configuration management with security-first approach
 * All environment variables classified per ISO 27001 A.8.2.1
 * 
 * Classification: CONFIDENTIAL (contains sensitive configuration)
 * Retention: Service lifetime (operational requirement)
 * Review Date: Every 3 months (critical configuration)
 */

import dotenv from 'dotenv';

// Load environment variables with path validation
const envPath = process.env.NODE_ENV === 'test' ? '.env.test' : '.env';
dotenv.config({ path: envPath });

/**
 * Environment configuration interface with strict typing
 * All properties are classified for compliance tracking
 */
interface EnvironmentConfig {
  // ?? Database Configuration (CRITICAL classification)
  readonly pgHost: string;
  readonly pgPort: number;
  readonly pgDatabase: string;
  readonly pgUser: string;
  readonly pgPassword: string;
  
  // ?? Authentication Configuration (CRITICAL classification)
  readonly jwtSecret: string;
  
  // ?? Service Configuration (HIGH classification)
  readonly tenantId: string;
  readonly serviceName: string;
  
  // ?? Network Configuration (INTERNAL classification)
  readonly backendPort: number;
  readonly backendHost: string;
  
  // ?? Environment Configuration (INTERNAL classification)
  readonly nodeEnv: 'development' | 'test' | 'production';
  readonly logLevel: 'debug' | 'info' | 'warn' | 'error';
  
  // ?? Integration Configuration (HIGH classification)
  readonly coreEnvsPrivateUrl?: string;
  readonly healthCheckInterval: number;
  
  // ?? External Authentication Configuration (HIGH classification)
  readonly apiUrl?: string;
  readonly authUrl?: string;
  readonly authUsername?: string;
  readonly authPassword?: string;
}

/**
 * Safe string conversion with validation
 */
function requireString(key: string, defaultValue?: string): string {
  const value = process.env[key] || defaultValue;
  if (!value) {
    throw new Error(`Required environment variable ${key} is not set`);
  }
  return value;
}

/**
 * Safe number conversion with validation
 */
function requireNumber(key: string, defaultValue?: number): number {
  const value = process.env[key];
  if (!value && defaultValue === undefined) {
    throw new Error(`Required environment variable ${key} is not set`);
  }
  
  const numValue = value ? parseInt(value, 10) : defaultValue!;
  if (isNaN(numValue)) {
    throw new Error(`Environment variable ${key} must be a valid number, got: ${value}`);
  }
  
  return numValue;
}

/**
 * Safe enum conversion with validation
 */
function requireEnum<T extends string>(
  key: string, 
  allowedValues: readonly T[], 
  defaultValue?: T
): T {
  const value = process.env[key] || defaultValue;
  if (!value) {
    throw new Error(`Required environment variable ${key} is not set`);
  }
  
  if (!allowedValues.includes(value as T)) {
    throw new Error(
      `Environment variable ${key} must be one of [${allowedValues.join(', ')}], got: ${value}`
    );
  }
  
  return value as T;
}

/**
 * Nuclear environment configuration
 * Fail-fast validation with comprehensive error messages
 */
const envConfig: EnvironmentConfig = {
  // ?? Database Configuration (CRITICAL - ISO 27001 A.8.2.1)
  pgHost: requireString('PGHOST'),
  pgPort: requireNumber('PGPORT', 5432),
  pgDatabase: requireString('PGDATABASE'),
  pgUser: requireString('PGUSER'),
  pgPassword: requireString('PGPASSWORD'),
  
  // ?? Authentication Configuration (CRITICAL - ISO 27001 A.9.4.1)
  jwtSecret: requireString('JWT_SECRET'),
  
  // ?? Service Configuration (HIGH - Business Critical)
  tenantId: requireString('TENANT_ID'),
  serviceName: requireString('SERVICE_NAME', 'core-backend'),
  
  // ?? Network Configuration (INTERNAL - Operational)
  backendPort: requireNumber('BACKEND_PORT', 3000),
  backendHost: requireString('BACKEND_HOST', '0.0.0.0'),
  
  // ?? Environment Configuration (INTERNAL - Operational)
  nodeEnv: requireEnum('NODE_ENV', ['development', 'test', 'production'] as const, 'development'),
  logLevel: requireEnum('LOG_LEVEL', ['debug', 'info', 'warn', 'error'] as const, 'info'),
  
  // ?? Integration Configuration (HIGH - External Dependencies)
  coreEnvsPrivateUrl: process.env.CORE_ENVS_PRIVATE_URL,
  healthCheckInterval: requireNumber('HEALTH_CHECK_INTERVAL', 60000), // 1 minute default
  
  // ?? External Authentication Configuration (HIGH - External API)
  apiUrl: process.env.API_URL,
  authUrl: process.env.AUTH_URL,
  authUsername: process.env.AUTH_USERNAME,
  authPassword: process.env.AUTH_PASSWORD,
};

/**
 * Configuration validation for security compliance
 * Validates configuration against security requirements
 */
function validateSecurityRequirements(config: EnvironmentConfig): void {
  // JWT Secret strength validation
  if (config.jwtSecret.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters for security compliance');
  }
  
  if (config.jwtSecret === 'default_secret_dangerous') {
    throw new Error('Default JWT_SECRET is not allowed in any environment');
  }
  
  // Production-specific validations
  if (config.nodeEnv === 'production') {
    // Database security in production
    if (config.pgHost === 'localhost' || config.pgHost === '127.0.0.1') {
      throw new Error('Production environment cannot use localhost database');
    }
    
    if (config.pgPassword.length < 12) {
      throw new Error('Production database password must be at least 12 characters');
    }
    
    // Network security in production
    if (config.backendPort < 1024) {
      console.warn('?? WARNING: Using privileged port in production requires root privileges');
    }
  }
  
  // Development-specific validations
  if (config.nodeEnv === 'development') {
    if (!config.pgHost.includes('localhost') && !config.pgHost.includes('127.0.0.1') && !config.pgHost.includes('dev')) {
      console.warn('?? WARNING: Development environment connecting to non-local database');
    }
  }
}

/**
 * Configuration classification for compliance tracking
 * Maps each configuration property to its ISO 27001 classification
 */
export const CONFIG_CLASSIFICATION = {
  // CRITICAL classification (A.8.2.1 - Highest security requirements)
  pgPassword: 'CRITICAL',
  jwtSecret: 'CRITICAL',
  
  // HIGH classification (Significant business impact)
  pgHost: 'HIGH',
  pgUser: 'HIGH',
  pgDatabase: 'HIGH',
  tenantId: 'HIGH',
  coreEnvsPrivateUrl: 'HIGH',
  apiUrl: 'HIGH',
  authUrl: 'HIGH',
  authUsername: 'HIGH',
  authPassword: 'HIGH',
  
  // INTERNAL classification (Internal operational data)
  pgPort: 'INTERNAL',
  serviceName: 'INTERNAL',
  backendPort: 'INTERNAL',
  backendHost: 'INTERNAL',
  nodeEnv: 'INTERNAL',
  logLevel: 'INTERNAL',
  healthCheckInterval: 'INTERNAL',
} as const;

/**
 * Get configuration value with classification context
 * Used for audit logging and compliance tracking
 */
export function getConfigWithClassification(key: keyof EnvironmentConfig): {
  value: any;
  classification: string;
  auditRequired: boolean;
} {
  const value = envConfig[key];
  const classification = CONFIG_CLASSIFICATION[key] || 'INTERNAL';
  const auditRequired = classification === 'CRITICAL' || classification === 'HIGH';
  
  // Never log CRITICAL values
  const safeValue = classification === 'CRITICAL' ? '[REDACTED]' : value;
  
  return {
    value: safeValue,
    classification,
    auditRequired
  };
}

/**
 * Validate configuration on module load
 * Ensures all requirements are met before service starts
 */
try {
  validateSecurityRequirements(envConfig);
} catch (error) {
  console.error('?? CRITICAL: Environment configuration validation failed');
  console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
  console.error('Service cannot start with invalid configuration');
  process.exit(1);
}

// Log successful configuration load (without sensitive data)
console.log('? Nuclear environment configuration loaded successfully', {
  nodeEnv: envConfig.nodeEnv,
  serviceName: envConfig.serviceName,
  backendPort: envConfig.backendPort,
  pgHost: envConfig.pgHost.includes('localhost') ? 'localhost' : '[REDACTED]',
  configClassifications: Object.keys(CONFIG_CLASSIFICATION).length,
  timestamp: new Date().toISOString()
});

export default envConfig;
// src/config/express.ts
/**
 * üö® CORE-BACKEND: Nuclear Express Configuration
 * 
 * Security-first Express middleware configuration
 * Compliance: Zero Trust + ISO 27001 + GDPR by design
 * 
 * Classification: CONFIDENTIAL (security configuration)
 * Retention: Service lifetime (operational requirement)
 * Review Date: Every 3 months (security critical)
 */

import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
// import compression from 'compression'; // Optional dependency
import { Request, Response, NextFunction } from 'express';
import envConfig from './envConfig';
import logger from '../utils/logger';

/**
 * Nuclear Express configuration
 * Applies security-first middleware stack with compliance controls
 */
const configureExpress = (app: express.Application): void => {
  // üîí STEP 1: Security headers (ISO 27001 A.13.2.1)
  configureSecurityHeaders(app);
  
  // üåê STEP 2: CORS configuration (Zero Trust)
  configureCORS(app);
  
  // üì¶ STEP 3: Body parsing with security limits
  configureBodyParsing(app);
  
  // üóúÔ∏è STEP 4: Compression for performance (OPTIONAL)
  // configureCompression(app);
  
  // üîó STEP 5: Correlation ID tracking (audit trail)
  configureCorrelationTracking(app);
  
  // üìä STEP 6: Request logging with compliance
  configureRequestLogging(app);
  
  // üõ°Ô∏è STEP 7: Method restrictions (attack surface reduction)
  configureMethodRestrictions(app);
  
  // üîç STEP 8: Health check endpoint (monitoring)
  configureHealthCheck(app);
  
  logger.info('‚úÖ Nuclear Express middleware configured', {
    classification: 'INTERNAL',
    audit_event: 'EXPRESS_MIDDLEWARE_CONFIGURED',
    environment: envConfig.nodeEnv,
    security_level: 'NUCLEAR'
  });
};

/**
 * Configure comprehensive security headers
 * Implements defense-in-depth security strategy
 */
function configureSecurityHeaders(app: express.Application): void {
  // Disable fingerprinting headers
  app.disable('x-powered-by');
  app.disable('etag');
  
  // Comprehensive security headers with Helmet
  app.use(helmet({
    // Content Security Policy - ENFORCED (not disabled like before)
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"], // For error pages only
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
        connectSrc: ["'self'"],
        fontSrc: ["'self'"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"],
        baseUri: ["'self'"],
        formAction: ["'self'"]
        // upgradeInsecureRequests: Production HTTPS should be handled at load balancer/proxy level
      }
    },
    
    // Cross-Origin policies
    crossOriginEmbedderPolicy: { policy: "credentialless" },
    crossOriginOpenerPolicy: { policy: "same-origin" },
    crossOriginResourcePolicy: { policy: "same-site" },
    
    // HTTPS enforcement in production
    hsts: {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true
    },
    
    // Additional security headers
    noSniff: true,
    frameguard: { action: 'deny' },
    xssFilter: true,
    referrerPolicy: { policy: "strict-origin-when-cross-origin" }
  }));
  
  // Custom security headers
  app.use((req: Request, res: Response, next: NextFunction) => {
    // Server identification obfuscation
    res.setHeader('Server', 'Core-Backend');
    
    // Cache control for security
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    
    // Custom compliance headers
    res.setHeader('X-Compliance-Level', 'Nuclear');
    res.setHeader('X-Classification', 'Confidential');
    
    next();
  });
}

/**
 * Configure CORS for multi-tenant security
 * Implements Zero Trust CORS policy
 */
function configureCORS(app: express.Application): void {
  const corsOptions: cors.CorsOptions = {
    origin: function (origin, callback) {
      // Allow requests with no origin (mobile apps, Postman, etc.)
      if (!origin) {
        return callback(null, true);
      }
      
      // Development: Allow localhost
      if (envConfig.nodeEnv === 'development') {
        if (origin.includes('localhost') || origin.includes('127.0.0.1')) {
          return callback(null, true);
        }
      }
      
      // Production: Strict origin validation
      const allowedOrigins = [
        'https://core-platform.company.com',
        'https://admin.company.com'
      ];
      
      if (envConfig.nodeEnv === 'production' && !allowedOrigins.includes(origin)) {
        logger.warn('üö´ CORS origin blocked', {
          classification: 'HIGH',
          audit_event: 'CORS_ORIGIN_BLOCKED',
          origin,
          security_violation: 'UNAUTHORIZED_ORIGIN'
        });
        
        return callback(new Error('Not allowed by CORS policy'), false);
      }
      
      callback(null, true);
    },
    
    credentials: true,
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Authorization', 
      'X-Trace-ID',
      'X-Tenant-Name',
      'X-Classification'
    ],
    exposedHeaders: ['X-Trace-ID', 'X-RateLimit-Remaining'],
    maxAge: 300 // 5 minutes preflight cache
  };
  
  app.use(cors(corsOptions));
  
  // CORS preflight audit logging
  app.options('*', (req: Request, res: Response) => {
    logger.info('üîç CORS preflight request', {
      classification: 'INTERNAL',
      audit_event: 'CORS_PREFLIGHT_REQUEST',
      origin: req.headers.origin,
      method: req.headers['access-control-request-method']
    });
    res.status(200).end();
  });
}

/**
 * Configure body parsing with security limits
 * Protects against payload-based attacks
 */
function configureBodyParsing(app: express.Application): void {
  // JSON parsing with strict limits
  app.use(express.json({
    limit: '1mb',  // Reduced from 2mb for security
    strict: true,  // Only parse objects and arrays
    verify: (req: Request, res: Response, buf: Buffer) => {
      // Store raw body for audit if needed
      (req as any).rawBody = buf;
    }
  }));
  
  // URL-encoded parsing (for form data if needed)
  app.use(express.urlencoded({
    limit: '1mb',
    extended: false, // Use simple querystring parser for security
    parameterLimit: 20 // Limit number of parameters
  }));
  
  // Reject requests with unsupported content types
  app.use((req: Request, res: Response, next: NextFunction) => {
    const contentType = req.headers['content-type'];
    
    if (req.method === 'POST' && contentType) {
      if (!contentType.includes('application/json') && 
          !contentType.includes('application/x-www-form-urlencoded')) {
        
        logger.warn('üö´ Unsupported content type rejected', {
          classification: 'HIGH',
          audit_event: 'UNSUPPORTED_CONTENT_TYPE',
          content_type: contentType,
          method: req.method,
          path: req.path
        });
        
        return res.status(415).json({
          error: 'Unsupported Media Type',
          supported: ['application/json']
        });
      }
    }
    
    next();
  });
}

/**
 * Configure compression for performance (OPTIONAL)
 * Applies intelligent compression based on content type
 */
/*
function configureCompression(app: express.Application): void {
  app.use(compression({
    level: 6, // Balanced compression
    threshold: 1024, // Only compress responses > 1KB
    filter: (req: Request, res: Response) => {
      // Don't compress if the response includes a Cache-Control no-transform directive
      if (res.getHeader('Cache-Control')?.toString().includes('no-transform')) {
        return false;
      }
      
      // Compress JSON responses (our main content)
      const contentType = res.getHeader('Content-Type')?.toString();
      return contentType?.includes('application/json') || false;
    }
  }));
}
*/

/**
 * Configure correlation ID tracking for audit trail
 * Implements comprehensive request tracing
 */
function configureCorrelationTracking(app: express.Application): void {
  app.use((req: Request, res: Response, next: NextFunction) => {
    // Generate or extract correlation ID
    const correlationId = req.headers['x-trace-id'] as string || 
                         generateCorrelationId();
    
    // Store in request for downstream use
    (req as any).correlationId = correlationId;
    
    // Add to response headers for client tracing
    res.setHeader('X-Trace-ID', correlationId);
    
    // Add tenant context if available
    const tenantName = req.headers['x-tenant-name'] as string;
    if (tenantName) {
      (req as any).tenantName = tenantName;
      res.setHeader('X-Tenant-Name', tenantName);
    }
    
    next();
  });
}

/**
 * Configure request logging with compliance classification
 * Implements comprehensive audit logging per ISO 27001 A.12.4.1
 */
function configureRequestLogging(app: express.Application): void {
  app.use((req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    const correlationId = (req as any).correlationId;
    const tenantName = (req as any).tenantName;
    
    // Log request start
    logger.info('üì• Request started', {
      classification: 'INTERNAL',
      audit_event: 'REQUEST_STARTED',
      correlation_id: correlationId,
      tenant_name: tenantName,
      method: req.method,
      path: req.path,
      user_agent: req.headers['user-agent'],
      ip_address: req.ip,
      content_length: req.headers['content-length']
    });
    
    // Capture response end with TypeScript bypass
    const originalEnd = res.end.bind(res);
    
    (res as any).end = (...args: any[]) => {
      const duration = Date.now() - startTime;
      
      // Log request completion
      logger.info('üì§ Request completed', {
        classification: 'INTERNAL',
        audit_event: 'REQUEST_COMPLETED',
        correlation_id: correlationId,
        tenant_name: tenantName,
        method: req.method,
        path: req.path,
        status_code: res.statusCode,
        duration_ms: duration,
        response_size: res.getHeader('content-length')
      });
      
      // Call original end function with all original arguments
      return originalEnd(...args);
    };
    
    next();
  });
}

/**
 * Configure HTTP method restrictions
 * Implements minimal attack surface principle
 */
function configureMethodRestrictions(app: express.Application): void {
  const allowedMethods = ['GET', 'POST', 'OPTIONS'];
  
  app.use((req: Request, res: Response, next: NextFunction) => {
    if (!allowedMethods.includes(req.method)) {
      logger.warn('üö´ Method not allowed', {
        classification: 'HIGH',
        audit_event: 'METHOD_NOT_ALLOWED',
        method: req.method,
        path: req.path,
        ip_address: req.ip,
        correlation_id: (req as any).correlationId
      });
      
      return res.status(405).json({
        error: 'Method Not Allowed',
        allowed_methods: allowedMethods
      });
    }
    
    next();
  });
}

/**
 * Configure health check endpoint
 * Provides monitoring without authentication
 */
function configureHealthCheck(app: express.Application): void {
  app.get('/health', (req: Request, res: Response) => {
    const healthStatus = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: envConfig.serviceName,
      version: '1.0.0', // Could be loaded from package.json
      environment: envConfig.nodeEnv,
      uptime: process.uptime(),
      memory: {
        used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
        rss: Math.round(process.memoryUsage().rss / 1024 / 1024)
      },
      compliance: {
        iso27001: 'active',
        gdpr: 'compliant',
        zero_trust: 'enforced'
      }
    };
    
    res.status(200).json(healthStatus);
  });
}

/**
 * Generate correlation ID for request tracing
 * Uses timestamp + random for uniqueness and sortability
 */
function generateCorrelationId(): string {
  const timestamp = Date.now().toString(36);
  const randomPart = Math.random().toString(36).substring(2, 8);
  return `${timestamp}-${randomPart}`;
}

export default configureExpress;
// src/controllers/authController.ts
/**
 * üö® CORE-BACKEND: Nuclear Authentication Controller
 * 
 * Simple but secure JWT authentication for multi-client access
 * Compatible with Oracle PL/SQL, JavaScript, Python clients
 * 
 * Classification: CONFIDENTIAL (authentication logic)
 * Retention: 7 years (security requirement)
 * Review Date: Every 3 months (critical security component)
 */

import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import envConfig from '../config/envConfig';
import logger from '../utils/logger';

/**
 * User record interface with security context
 */
interface UserRecord {
  readonly username: string;
  readonly password_hash: string;
  readonly role: string;
  readonly enabled: boolean;
  readonly created_at: string;
  readonly last_login?: string;
  readonly failed_attempts: number;
  readonly locked_until?: string;
}

/**
 * JWT payload interface
 */
interface JWTPayload {
  username: string;
  role: string;
  tenant_id: string;
  iat: number;
  exp: number;
}

/**
 * Authentication response interface
 */
interface AuthResponse {
  token: string;
  expires_in: number;
  token_type: 'Bearer';
  issued_at: string;
  user: {
    username: string;
    role: string;
    tenant_id: string;
  };
}

/**
 * Load users from core-envs-private configuration
 * This will be replaced with actual core-envs-private integration
 * For now, uses environment variables with secure defaults
 */
function loadUsersFromCoreEnvs(): Record<string, UserRecord> {
  // TODO: Replace with actual core-envs-private integration
  // For development, load from environment variables
  
  const users: Record<string, UserRecord> = {};
  
  // Core services user (primary service account)
  const coreServicesUsername = process.env.CORE_SERVICES_USERNAME || 'core-services';
  const coreServicesPassword = process.env.CORE_SERVICES_PASSWORD_HASH;
  
  if (coreServicesPassword) {
    users[coreServicesUsername] = {
      username: coreServicesUsername,
      password_hash: coreServicesPassword,
      role: 'service',
      enabled: true,
      created_at: new Date().toISOString(),
      failed_attempts: 0
    };
  }
  
  // Admin user (for administrative access)
  const adminUsername = process.env.ADMIN_USERNAME || 'admin';
  const adminPassword = process.env.ADMIN_PASSWORD_HASH;
  
  if (adminPassword) {
    users[adminUsername] = {
      username: adminUsername,
      password_hash: adminPassword,
      role: 'admin',
      enabled: true,
      created_at: new Date().toISOString(),
      failed_attempts: 0
    };
  }
  
  // Validate at least one user exists
  if (Object.keys(users).length === 0) {
    logger.error('üí• CRITICAL: No users configured for authentication', {
      classification: 'CRITICAL',
      audit_event: 'NO_USERS_CONFIGURED',
      security_impact: 'AUTHENTICATION_UNAVAILABLE'
    });
    
    throw new Error('No authentication users configured');
  }
  
  logger.info('‚úÖ Users loaded from configuration', {
    classification: 'HIGH',
    audit_event: 'USERS_LOADED',
    user_count: Object.keys(users).length,
    usernames: Object.keys(users) // Safe to log usernames
  });
  
  return users;
}

/**
 * Get users with caching and error handling
 * Implements circuit breaker pattern for resilience
 */
let cachedUsers: Record<string, UserRecord> | null = null;
let lastUserLoad = 0;
const USER_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

function getUsers(): Record<string, UserRecord> {
  const now = Date.now();
  
  // Use cached users if still valid
  if (cachedUsers && (now - lastUserLoad) < USER_CACHE_TTL) {
    return cachedUsers;
  }
  
  try {
    cachedUsers = loadUsersFromCoreEnvs();
    lastUserLoad = now;
    return cachedUsers;
  } catch (error) {
    logger.error('üí• Failed to load users', {
      classification: 'CRITICAL',
      audit_event: 'USER_LOAD_FAILED',
      error: error instanceof Error ? error.message : String(error)
    });
    
    // If we have cached users, use them as fallback
    if (cachedUsers) {
      logger.warn('‚ö†Ô∏è Using cached users as fallback', {
        classification: 'HIGH',
        audit_event: 'USER_CACHE_FALLBACK'
      });
      return cachedUsers;
    }
    
    throw error;
  }
}

/**
 * Validate user credentials with security controls
 */
async function validateCredentials(
  username: string, 
  password: string,
  clientIp: string,
  correlationId: string
): Promise<{ valid: boolean; user?: UserRecord; reason?: string }> {
  
  const users = getUsers();
  const user = users[username];
  
  // User not found
  if (!user) {
    logger.warn('üö´ Authentication failed - user not found', {
      classification: 'HIGH',
      audit_event: 'AUTH_USER_NOT_FOUND',
      username,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    return { valid: false, reason: 'Invalid credentials' };
  }
  
  // User disabled
  if (!user.enabled) {
    logger.warn('üö´ Authentication failed - user disabled', {
      classification: 'HIGH',
      audit_event: 'AUTH_USER_DISABLED',
      username,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    return { valid: false, reason: 'Account disabled' };
  }
  
  // Account locked
  if (user.locked_until && new Date(user.locked_until) > new Date()) {
    logger.warn('üö´ Authentication failed - account locked', {
      classification: 'HIGH',
      audit_event: 'AUTH_USER_LOCKED',
      username,
      locked_until: user.locked_until,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    return { valid: false, reason: 'Account temporarily locked' };
  }
  
  // Validate password
  try {
    const passwordValid = await bcrypt.compare(password, user.password_hash);
    
    if (!passwordValid) {
      logger.warn('üö´ Authentication failed - invalid password', {
        classification: 'HIGH',
        audit_event: 'AUTH_INVALID_PASSWORD',
        username,
        failed_attempts: user.failed_attempts + 1,
        client_ip: clientIp,
        correlation_id: correlationId
      });
      
      return { valid: false, reason: 'Invalid credentials' };
    }
    
    logger.info('‚úÖ Authentication successful', {
      classification: 'HIGH',
      audit_event: 'AUTH_SUCCESS',
      username,
      role: user.role,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    return { valid: true, user };
    
  } catch (error) {
    logger.error('üí• Password validation error', {
      classification: 'CRITICAL',
      audit_event: 'AUTH_VALIDATION_ERROR',
      username,
      error: error instanceof Error ? error.message : String(error),
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    return { valid: false, reason: 'Authentication error' };
  }
}

/**
 * Generate secure JWT token
 */
function generateJWT(user: UserRecord, correlationId: string): { token: string; expiresIn: number } {
  const now = Math.floor(Date.now() / 1000);
  const expiresIn = 15 * 60; // 15 minutes for security
  
  const payload: JWTPayload = {
    username: user.username,
    role: user.role,
    tenant_id: envConfig.tenantId,
    iat: now,
    exp: now + expiresIn
  };
  
  const token = jwt.sign(payload, envConfig.jwtSecret, {
    algorithm: 'HS256',
    issuer: 'core-backend',
    audience: 'core-platform'
  });
  
  logger.info('üîë JWT token generated', {
    classification: 'HIGH',
    audit_event: 'JWT_GENERATED',
    username: user.username,
    role: user.role,
    expires_in: expiresIn,
    correlation_id: correlationId
  });
  
  return { token, expiresIn };
}

/**
 * Login endpoint
 * Authenticates user and returns JWT token
 */
export const login = async (req: Request, res: Response): Promise<void> => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || 'unknown';
  const clientIp = req.ip || 'unknown';
  
  try {
    // Input validation
    const { username, password } = req.body;
    
    if (!username || !password) {
      logger.warn('üö´ Login failed - missing credentials', {
        classification: 'HIGH',
        audit_event: 'LOGIN_MISSING_CREDENTIALS',
        has_username: !!username,
        has_password: !!password,
        client_ip: clientIp,
        correlation_id: correlationId
      });
      
      res.status(400).json({
        error: 'Username and password are required',
        correlation_id: correlationId
      });
      return;
    }
    
    // Validate input format
    if (typeof username !== 'string' || typeof password !== 'string') {
      logger.warn('üö´ Login failed - invalid input format', {
        classification: 'HIGH',
        audit_event: 'LOGIN_INVALID_FORMAT',
        username_type: typeof username,
        password_type: typeof password,
        client_ip: clientIp,
        correlation_id: correlationId
      });
      
      res.status(400).json({
        error: 'Invalid input format',
        correlation_id: correlationId
      });
      return;
    }
    
    // Validate credentials
    const validation = await validateCredentials(username, password, clientIp, correlationId);
    
    if (!validation.valid || !validation.user) {
      res.status(401).json({
        error: validation.reason || 'Authentication failed',
        correlation_id: correlationId
      });
      return;
    }
    
    // Generate JWT
    const { token, expiresIn } = generateJWT(validation.user, correlationId);
    
    // Prepare response
    const response: AuthResponse = {
      token,
      expires_in: expiresIn,
      token_type: 'Bearer',
      issued_at: new Date().toISOString(),
      user: {
        username: validation.user.username,
        role: validation.user.role,
        tenant_id: envConfig.tenantId
      }
    };
    
    const duration = Date.now() - startTime;
    
    logger.info('‚úÖ Login successful', {
      classification: 'HIGH',
      audit_event: 'LOGIN_SUCCESS',
      username: validation.user.username,
      role: validation.user.role,
      duration_ms: duration,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    res.status(200).json(response);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('üí• Login error', {
      classification: 'CRITICAL',
      audit_event: 'LOGIN_ERROR',
      error: error instanceof Error ? error.message : String(error),
      duration_ms: duration,
      client_ip: clientIp,
      correlation_id: correlationId
    });
    
    res.status(500).json({
      error: 'Internal authentication error',
      correlation_id: correlationId
    });
  }
};

/**
 * Token validation endpoint
 * Validates JWT token and returns user info
 */
export const validateToken = async (req: Request, res: Response): Promise<void> => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        error: 'Missing or invalid authorization header',
        correlation_id: correlationId
      });
      return;
    }
    
    const token = authHeader.split(' ')[1];
    
    try {
      const payload = jwt.verify(token, envConfig.jwtSecret) as JWTPayload;
      
      logger.info('‚úÖ Token validation successful', {
        classification: 'INTERNAL',
        audit_event: 'TOKEN_VALIDATED',
        username: payload.username,
        role: payload.role,
        correlation_id: correlationId
      });
      
      res.status(200).json({
        valid: true,
        user: {
          username: payload.username,
          role: payload.role,
          tenant_id: payload.tenant_id
        },
        expires_at: new Date(payload.exp * 1000).toISOString(),
        correlation_id: correlationId
      });
      
    } catch (jwtError) {
      logger.warn('üö´ Token validation failed', {
        classification: 'HIGH',
        audit_event: 'TOKEN_VALIDATION_FAILED',
        error: jwtError instanceof Error ? jwtError.message : String(jwtError),
        correlation_id: correlationId
      });
      
      res.status(401).json({
        error: 'Invalid or expired token',
        correlation_id: correlationId
      });
    }
    
  } catch (error) {
    logger.error('üí• Token validation error', {
      classification: 'CRITICAL',
      audit_event: 'TOKEN_VALIDATION_ERROR',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
    
    res.status(500).json({
      error: 'Token validation error',
      correlation_id: correlationId
    });
  }
};

/**
 * Token refresh endpoint (optional)
 * Refreshes JWT token if still valid
 */
export const refreshToken = async (req: Request, res: Response): Promise<void> => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        error: 'Missing or invalid authorization header',
        correlation_id: correlationId
      });
      return;
    }
    
    const token = authHeader.split(' ')[1];
    
    try {
      // Verify current token (even if expired, we check the payload)
      const payload = jwt.verify(token, envConfig.jwtSecret, { ignoreExpiration: true }) as JWTPayload;
      
      // Check if token is not too old (max 1 hour for refresh)
      const now = Math.floor(Date.now() / 1000);
      const tokenAge = now - payload.iat;
      const maxRefreshAge = 60 * 60; // 1 hour
      
      if (tokenAge > maxRefreshAge) {
        res.status(401).json({
          error: 'Token too old for refresh',
          correlation_id: correlationId
        });
        return;
      }
      
      // Get user to ensure still valid
      const users = getUsers();
      const user = users[payload.username];
      
      if (!user || !user.enabled) {
        res.status(401).json({
          error: 'User no longer valid',
          correlation_id: correlationId
        });
        return;
      }
      
      // Generate new token
      const { token: newToken, expiresIn } = generateJWT(user, correlationId);
      
      logger.info('üîÑ Token refreshed', {
        classification: 'HIGH',
        audit_event: 'TOKEN_REFRESHED',
        username: payload.username,
        correlation_id: correlationId
      });
      
      res.status(200).json({
        token: newToken,
        expires_in: expiresIn,
        token_type: 'Bearer',
        issued_at: new Date().toISOString(),
        correlation_id: correlationId
      });
      
    } catch (jwtError) {
      res.status(401).json({
        error: 'Invalid token for refresh',
        correlation_id: correlationId
      });
    }
    
  } catch (error) {
    logger.error('üí• Token refresh error', {
      classification: 'CRITICAL',
      audit_event: 'TOKEN_REFRESH_ERROR',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
    
    res.status(500).json({
      error: 'Token refresh error',
      correlation_id: correlationId
    });
  }
};
// src/controllers/log/emitter.ts
/**
 * ?? CORE-BACKEND: Log Emitter Controller
 * 
 * Test endpoint for generating sample logs
 * Useful for testing log ingestion and demo purposes
 * 
 * Classification: INTERNAL (testing functionality)
 * Retention: Not applicable (test endpoint)
 * Review Date: Every 6 months
 */

import { Request, Response } from 'express';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import envConfig from '../../config/envConfig';
import logger from '../../utils/logger';

/**
 * Sample log templates for different scenarios
 */
const LOG_TEMPLATES = {
  auth: [
    { level: 'info', message: 'User authentication successful', classification: 'internal' },
    { level: 'warn', message: 'Failed login attempt detected', classification: 'confidential' },
    { level: 'error', message: 'Authentication service unavailable', classification: 'internal' }
  ],
  api: [
    { level: 'info', message: 'API request processed successfully', classification: 'public' },
    { level: 'warn', message: 'API rate limit approaching threshold', classification: 'internal' },
    { level: 'error', message: 'API endpoint returned 5xx error', classification: 'internal' }
  ],
  database: [
    { level: 'info', message: 'Database query executed successfully', classification: 'internal' },
    { level: 'warn', message: 'Database connection pool near capacity', classification: 'internal' },
    { level: 'error', message: 'Database transaction failed', classification: 'confidential' }
  ],
  security: [
    { level: 'warn', message: 'Suspicious activity detected from IP', classification: 'confidential' },
    { level: 'error', message: 'Potential SQL injection attempt blocked', classification: 'restricted' },
    { level: 'critical', message: 'Multiple failed authentication attempts', classification: 'restricted' }
  ],
  business: [
    { level: 'info', message: 'New user registration completed', classification: 'internal' },
    { level: 'info', message: 'Payment processed successfully', classification: 'confidential' },
    { level: 'error', message: 'Payment gateway timeout', classification: 'confidential' }
  ]
};

/**
 * Services that might emit logs
 */
const SERVICES = [
  'auth-service',
  'api-gateway',
  'payment-service',
  'user-service',
  'notification-service',
  'analytics-service',
  'report-service'
];

/**
 * Generate random log data
 */
function generateRandomLog(category?: string) {
  const categories = Object.keys(LOG_TEMPLATES);
  const selectedCategory = category || categories[Math.floor(Math.random() * categories.length)];
  const templates = LOG_TEMPLATES[selectedCategory as keyof typeof LOG_TEMPLATES];
  const template = templates[Math.floor(Math.random() * templates.length)];
  const service = SERVICES[Math.floor(Math.random() * SERVICES.length)];
  
  return {
    tenant_name: envConfig.tenantId || 'core-dev',
    service,
    level: template.level,
    message: template.message,
    classification: template.classification,
    trace_id: uuidv4(),
    timestamp: new Date().toISOString(),
    tags: [selectedCategory, service, template.level],
    context: {
      category: selectedCategory,
      environment: envConfig.nodeEnv,
      host: envConfig.backendHost,
      random_value: Math.floor(Math.random() * 1000),
      user_id: `user-${Math.floor(Math.random() * 10000)}`,
      session_id: uuidv4(),
      ip_address: `192.168.1.${Math.floor(Math.random() * 255)}`
    }
  };
}

/**
 * Send log to the ingestion endpoint
 */
async function sendLogToEndpoint(logData: any, authToken?: string): Promise<any> {
  const url = `http://localhost:${envConfig.backendPort}/api/emit-log`;
  
  const headers: any = {
    'Content-Type': 'application/json',
    'X-Trace-ID': logData.trace_id
  };
  
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`;
  }
  
  const response = await axios.post(url, logData, { headers });
  return response.data;
}

/**
 * Generate and emit test logs
 * POST /emit-log (for backward compatibility with appRoutes.ts)
 * 
 * This endpoint generates sample logs and sends them to the actual log ingestion endpoint
 */
export const generateLogEmitter = async (req: Request, res: Response): Promise<void> => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || uuidv4();
  
  try {
    // Extract parameters from request
    const {
      count = 1,
      category,
      burst = false,
      includeErrors = false,
      delayMs = 0
    } = req.body || {};
    
    // Validate count
    if (count < 1 || count > 100) {
      res.status(400).json({
        error: 'Count must be between 1 and 100',
        correlation_id: correlationId
      });
      return;
    }
    
    logger.info('?? Test log generation started', {
      classification: 'INTERNAL',
      audit_event: 'TEST_LOG_GENERATION',
      count,
      category,
      burst,
      correlation_id: correlationId
    });
    
    const results = [];
    const errors = [];
    
    // Get auth token from current request
    const authToken = req.headers.authorization?.replace('Bearer ', '');
    
    // Generate and send logs
    for (let i = 0; i < count; i++) {
      try {
        // Generate log data
        const logData = generateRandomLog(category);
        
        // Add error logs if requested
        if (includeErrors && i % 3 === 0) {
          logData.level = 'error';
          logData.message = `Simulated error #${i}: ${logData.message}`;
        }
        
        // Add delay between logs if not burst mode
        if (!burst && delayMs > 0 && i > 0) {
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
        
        // Send to actual log ingestion endpoint
        const result = await sendLogToEndpoint(logData, authToken);
        
        results.push({
          index: i,
          log_id: result.log_id,
          trace_id: logData.trace_id,
          level: logData.level,
          service: logData.service
        });
        
      } catch (error) {
        errors.push({
          index: i,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const duration = Date.now() - startTime;
    
    // Prepare response
    const response: any = {
      status: errors.length === 0 ? 'success' : 'partial_success',
      message: `Generated and sent ${results.length} test logs`,
      correlation_id: correlationId,
      processing_time_ms: duration,
      results: {
        total_requested: count,
        successful: results.length,
        failed: errors.length
      }
    };
    
    if (results.length > 0) {
      response.sample_results = results.slice(0, 5); // First 5 results
    }
    
    if (errors.length > 0) {
      response.errors = errors;
    }
    
    res.status(errors.length === 0 ? 200 : 207).json(response);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('?? Test log generation failed', {
      classification: 'HIGH',
      audit_event: 'TEST_LOG_GENERATION_FAILED',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId,
      duration_ms: duration
    });
    
    res.status(500).json({
      error: 'Failed to generate test logs',
      details: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
  }
};

/**
 * Generate burst of logs for load testing
 * POST /api/logs/burst
 */
export const generateLogBurst = async (req: Request, res: Response): Promise<void> => {
  const correlationId = (req as any).correlationId || uuidv4();
  
  try {
    const {
      total = 1000,
      batchSize = 100,
      delayBetweenBatches = 1000
    } = req.body || {};
    
    logger.info('?? Log burst generation started', {
      classification: 'INTERNAL',
      audit_event: 'LOG_BURST_STARTED',
      total,
      batchSize,
      correlation_id: correlationId
    });
    
    const batches = Math.ceil(total / batchSize);
    let totalSent = 0;
    let totalErrors = 0;
    
    for (let batch = 0; batch < batches; batch++) {
      const logsInBatch = Math.min(batchSize, total - totalSent);
      
      // Generate batch
      const logs = [];
      for (let i = 0; i < logsInBatch; i++) {
        logs.push(generateRandomLog());
      }
      
      // Send batch (you might want to implement actual batch sending)
      try {
        // This is simplified - in reality you'd send these in parallel or use a batch endpoint
        const authToken = req.headers.authorization?.replace('Bearer ', '');
        for (const log of logs) {
          await sendLogToEndpoint(log, authToken);
          totalSent++;
        }
      } catch (error) {
        totalErrors++;
      }
      
      // Delay between batches
      if (batch < batches - 1) {
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
      }
    }
    
    res.status(200).json({
      status: 'completed',
      message: `Burst generation completed`,
      correlation_id: correlationId,
      results: {
        total_requested: total,
        total_sent: totalSent,
        total_errors: totalErrors,
        batches_processed: batches
      }
    });
    
  } catch (error) {
    logger.error('?? Log burst generation failed', {
      classification: 'HIGH',
      audit_event: 'LOG_BURST_FAILED',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
    
    res.status(500).json({
      error: 'Failed to generate log burst',
      correlation_id: correlationId
    });
  }
};

/**
 * Get available log templates
 * GET /api/logs/templates
 */
export const getLogTemplates = async (req: Request, res: Response): Promise<void> => {
  res.status(200).json({
    status: 'success',
    templates: LOG_TEMPLATES,
    categories: Object.keys(LOG_TEMPLATES),
    services: SERVICES,
    usage: {
      single_log: 'POST /emit-log { count: 1, category: "auth" }',
      multiple_logs: 'POST /emit-log { count: 10, delayMs: 100 }',
      burst_mode: 'POST /emit-log { count: 50, burst: true }',
      with_errors: 'POST /emit-log { count: 20, includeErrors: true }'
    }
  });
};
// src/controllers/logController.ts
/**
 * üö® CORE-BACKEND: Nuclear Log Ingestion Controller
 * 
 * Single responsibility: Log ingestion endpoint ONLY
 * Multi-tenant log processing with comprehensive compliance
 * 
 * Classification: CONFIDENTIAL (log processing logic)
 * Retention: 7 years (operational requirement)
 * Review Date: Every 3 months (critical component)
 */

import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod';
import db from '../config/db';
import logger from '../utils/logger';
import nuclearAuditLogger from '../middlewares/auditLogger';

/**
 * Log payload validation schema
 * Enforces strict validation for compliance and security
 */
const logPayloadSchema = z.object({
  // üè¢ Tenant identification (HIGH classification)
  tenant_name: z.string()
    .min(1, 'Tenant name cannot be empty')
    .max(64, 'Tenant name too long')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid tenant name format')
    .trim(),
  
  // üîß Service identification (INTERNAL classification)
  service: z.string()
    .min(1, 'Service name cannot be empty')
    .max(64, 'Service name too long')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid service name format')
    .trim(),
  
  // üìä Log level (INTERNAL classification)
  level: z.enum(['debug', 'info', 'warn', 'error', 'critical'], {
    errorMap: () => ({ message: 'Level must be one of: debug, info, warn, error, critical' })
  }),
  
  // üìù Log message (varies by classification)
  message: z.string()
    .min(1, 'Message cannot be empty')
    .max(8192, 'Message too long (max 8KB)')
    .trim(),
  
  // ‚è∞ Timestamp (INTERNAL classification)
  timestamp: z.string()
    .datetime({ message: 'Invalid ISO 8601 timestamp format' })
    .optional()
    .transform(val => val || new Date().toISOString()),
  
  // üîó Trace ID (INTERNAL classification)
  trace_id: z.string()
    .uuid('Invalid UUID format for trace_id')
    .optional()
    .transform(val => val || uuidv4()),
  
  // üîí Classification (MANDATORY for compliance)
  classification: z.enum(['public', 'internal', 'confidential', 'restricted'], {
    errorMap: () => ({ message: 'Classification must be one of: public, internal, confidential, restricted' })
  }),
  
  // üìÖ Retention period (GDPR compliance)
  retention_period: z.number()
    .int('Retention period must be an integer')
    .min(1, 'Retention period must be at least 1 day')
    .max(3650, 'Retention period cannot exceed 10 years') // ISO 27001 maximum
    .default(365), // 1 year default
  
  // üè∑Ô∏è Tags (OPTIONAL - INTERNAL classification)
  tags: z.array(z.string().trim().max(50))
    .max(20, 'Maximum 20 tags allowed')
    .optional()
    .default([]),
  
  // üìã Context metadata (OPTIONAL - varies by classification)
  context: z.record(z.any())
    .optional()
    .default({})
    .refine(
      (obj) => JSON.stringify(obj).length <= 32768, // 32KB limit
      { message: 'Context metadata too large (max 32KB when serialized)' }
    )
});

/**
 * Classification-based retention periods (ISO 27001 + GDPR compliance)
 */
const CLASSIFICATION_RETENTION: Record<string, number> = {
  'public': 30,        // 30 days
  'internal': 365,     // 1 year
  'confidential': 2555, // 7 years
  'restricted': 3650   // 10 years
};

/**
 * Classification validation and enforcement
 * Ensures compliance with ISO 27001 A.8.2.1
 */
function validateClassification(payload: any, correlationId: string): {
  isValid: boolean;
  adjustedRetention?: number;
  warnings?: string[];
} {
  const warnings: string[] = [];
  const { classification, retention_period } = payload;
  
  // Get recommended retention for classification
  const recommendedRetention = CLASSIFICATION_RETENTION[classification];
  
  // If retention period is longer than recommended, warn but allow
  if (retention_period > recommendedRetention) {
    const warning = `Retention period ${retention_period} days exceeds recommendation for ${classification} classification (${recommendedRetention} days)`;
    warnings.push(warning);
    
    logger.warn('‚ö†Ô∏è Retention period exceeds classification recommendation', {
      classification: 'INTERNAL',
      audit_event: 'RETENTION_PERIOD_EXCESSIVE',
      tenant_classification: classification,
      requested_retention: retention_period,
      recommended_retention: recommendedRetention,
      correlation_id: correlationId
    });
  }
  
  // If retention period is shorter than minimum for classification, adjust
  if (retention_period < recommendedRetention) {
    warnings.push(`Retention period adjusted from ${retention_period} to ${recommendedRetention} days for ${classification} classification`);
    
    logger.info('üîß Retention period adjusted for compliance', {
      classification: 'INTERNAL',
      audit_event: 'RETENTION_PERIOD_ADJUSTED',
      tenant_classification: classification,
      original_retention: retention_period,
      adjusted_retention: recommendedRetention,
      correlation_id: correlationId
    });
    
    return {
      isValid: true,
      adjustedRetention: recommendedRetention,
      warnings
    };
  }
  
  return {
    isValid: true,
    adjustedRetention: retention_period,
    warnings: warnings.length > 0 ? warnings : undefined
  };
}

/**
 * Audit trail logging for log ingestion
 * Implements ISO 27001 A.12.4.1 comprehensive event logging
 */
function auditLogIngestion(
  operation: string,
  payload: any,
  result: any,
  correlationId: string,
  clientIp: string,
  duration?: number
): void {
  const auditLevel = payload.classification === 'restricted' || payload.classification === 'confidential' ? 'HIGH' : 'INTERNAL';
  
  logger.info(`üìä Log ingestion: ${operation}`, {
    classification: auditLevel,
    audit_event: `LOG_INGESTION_${operation.toUpperCase()}`,
    tenant_name: payload.tenant_name,
    service: payload.service,
    log_level: payload.level,
    log_classification: payload.classification,
    retention_period: result.retention_until ? 'calculated' : 'default',
    trace_id: payload.trace_id,
    correlation_id: correlationId,
    client_ip: clientIp,
    duration_ms: duration,
    compliance_validated: true
  });
}

/**
 * Nuclear log ingestion endpoint
 * POST /api/emit-log
 */
export const emitLog = async (req: Request, res: Response): Promise<void> => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || 'unknown';
  const clientIp = req.ip || 'unknown';
  
  try {
    // üîç STEP 1: Input validation with comprehensive schema
    logger.info('üîç Starting log ingestion validation', {
      classification: 'INTERNAL',
      audit_event: 'LOG_INGESTION_STARTED',
      correlation_id: correlationId,
      client_ip: clientIp
    });
    
    const validationResult = logPayloadSchema.safeParse(req.body);
    
    if (!validationResult.success) {
      const errors = validationResult.error.errors;
      
      logger.warn('üö´ Log payload validation failed', {
        classification: 'HIGH',
        audit_event: 'LOG_VALIDATION_FAILED',
        error_count: errors.length,
        errors: errors.map(e => ({ field: e.path.join('.'), message: e.message })),
        correlation_id: correlationId,
        client_ip: clientIp
      });
      
      res.status(400).json({
        error: 'Invalid log payload',
        details: errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        })),
        correlation_id: correlationId
      });
      return;
    }
    
    const payload = validationResult.data;
    
    // üõ°Ô∏è STEP 2: Classification validation and compliance check
    const classificationValidation = validateClassification(payload, correlationId);
    
    if (!classificationValidation.isValid) {
      res.status(400).json({
        error: 'Classification validation failed',
        correlation_id: correlationId
      });
      return;
    }
    
    // Use adjusted retention period if necessary
    const finalRetentionPeriod = classificationValidation.adjustedRetention || payload.retention_period;
    const retentionUntil = new Date();
    retentionUntil.setDate(retentionUntil.getDate() + finalRetentionPeriod);
    
    // üóÑÔ∏è STEP 3: Database insertion with transaction
    const insertQuery = `
      INSERT INTO logs (
        tenant_name, service, timestamp, level, message, 
        tags, context, trace_id, classification, 
        retention_until, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING id, created_at
    `;
    
    const insertValues = [
      payload.tenant_name,
      payload.service,
      new Date(payload.timestamp),
      payload.level,
      payload.message,
      payload.tags,
      JSON.stringify(payload.context),
      payload.trace_id,
      payload.classification,
      retentionUntil,
      new Date()
    ];
    
    const dbResult = await db.query(insertQuery, insertValues);
    const insertedLog = dbResult.rows[0];
    
    const duration = Date.now() - startTime;
    
    // üìä STEP 4: Audit trail logging
    auditLogIngestion('SUCCESS', payload, {
      id: insertedLog.id,
      retention_until: retentionUntil
    }, correlationId, clientIp, duration);
    
    // üìä STEP 5: Log ingestion audit event
    nuclearAuditLogger.logLogIngestion(
      payload.tenant_name,
      payload.classification,
      req,
      true,
      {
        log_id: insertedLog.id,
        service: payload.service,
        log_level: payload.level,
        retention_until: retentionUntil.toISOString(),
        processing_time_ms: duration
      }
    );
    
    // üì§ STEP 6: Success response
    const response = {
      status: 'success',
      message: 'Log ingested successfully',
      log_id: insertedLog.id,
      trace_id: payload.trace_id,
      tenant_name: payload.tenant_name,
      classification: payload.classification,
      retention_until: retentionUntil.toISOString(),
      warnings: classificationValidation.warnings,
      correlation_id: correlationId,
      processing_time_ms: duration
    };
    
    res.status(201).json(response);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    // Handle specific database errors
    if (error instanceof Error) {
      if (error.message.includes('connection')) {
        logger.error('üí• Database connection error during log ingestion', {
          classification: 'CRITICAL',
          audit_event: 'LOG_INGESTION_DB_CONNECTION_ERROR',
          error: error.message,
          correlation_id: correlationId,
          client_ip: clientIp,
          duration_ms: duration
        });
        
        res.status(503).json({
          error: 'Database service unavailable',
          correlation_id: correlationId,
          retry_after: '30 seconds'
        });
        return;
      }
      
      if (error.message.includes('constraint')) {
        logger.error('üí• Database constraint violation during log ingestion', {
          classification: 'HIGH',
          audit_event: 'LOG_INGESTION_CONSTRAINT_VIOLATION',
          error: error.message,
          correlation_id: correlationId,
          client_ip: clientIp,
          duration_ms: duration
        });
        
        res.status(409).json({
          error: 'Data constraint violation',
          correlation_id: correlationId
        });
        return;
      }
    }
    
    // Generic error handling
    logger.error('üí• Log ingestion failed', {
      classification: 'CRITICAL',
      audit_event: 'LOG_INGESTION_FAILED',
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      correlation_id: correlationId,
      client_ip: clientIp,
      duration_ms: duration
    });
    
    res.status(500).json({
      error: 'Internal server error during log ingestion',
      correlation_id: correlationId
    });
  }
};

/**
 * Log ingestion health check
 * GET /api/logs/health
 */
export const logHealthCheck = async (req: Request, res: Response): Promise<void> => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  try {
    // Test database connectivity
    const dbHealthQuery = 'SELECT 1 as healthy, NOW() as timestamp';
    const dbResult = await db.query(dbHealthQuery);
    
    const healthStatus = {
      status: 'healthy',
      service: 'log-ingestion',
      timestamp: new Date().toISOString(),
      database: {
        status: 'connected',
        response_time: dbResult.rows[0].timestamp
      },
      compliance: {
        iso27001: 'active',
        gdpr: 'compliant',
        data_classification: 'enforced'
      },
      endpoints: {
        emit_log: 'available'
      },
      retention: {
        policy: 'automated',
        classifications: Object.keys(CLASSIFICATION_RETENTION)
      },
      correlation_id: correlationId
    };
    
    res.status(200).json(healthStatus);
    
  } catch (error) {
    logger.error('üí• Log service health check failed', {
      classification: 'HIGH',
      audit_event: 'LOG_HEALTH_CHECK_FAILED',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
    
    res.status(503).json({
      status: 'unhealthy',
      service: 'log-ingestion',
      timestamp: new Date().toISOString(),
      error: 'Service health check failed',
      correlation_id: correlationId
    });
  }
};
// src/controllers/metrics/receive.ts
/**
 * ?? CORE-BACKEND: Nuclear Metrics Controller
 * 
 * Performance and business metrics ingestion endpoint
 * Supports multi-tenant metric collection with compliance
 * 
 * Classification: CONFIDENTIAL (metrics processing logic)
 * Retention: 90 days (operational metrics)
 * Review Date: Every 3 months (critical component)
 */

import { Request, Response } from 'express';
import { z } from 'zod';
import db from '../../config/db';
import logger from '../../utils/logger';
import nuclearAuditLogger from '../../middlewares/auditLogger';

/**
 * Metric payload validation schema
 * Enforces strict validation for metrics data
 */
const metricPayloadSchema = z.object({
  // ?? Metric identification
  metric_name: z.string()
    .min(1, 'Metric name cannot be empty')
    .max(128, 'Metric name too long')
    .regex(/^[a-zA-Z0-9_.-]+$/, 'Invalid metric name format')
    .trim(),
  
  metric_value: z.number()
    .finite('Metric value must be finite'),
  
  metric_unit: z.string()
    .max(50, 'Metric unit too long')
    .optional(),
  
  // ?? Context
  service: z.string()
    .min(1, 'Service name cannot be empty')
    .max(64, 'Service name too long')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid service name format')
    .trim(),
  
  tenant_name: z.string()
    .min(1, 'Tenant name cannot be empty')
    .max(64, 'Tenant name too long')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid tenant name format')
    .trim()
    .optional(),
  
  hostname: z.string()
    .max(256, 'Hostname too long')
    .optional(),
  
  // ? Timestamp
  timestamp: z.string()
    .datetime({ message: 'Invalid ISO 8601 timestamp format' })
    .optional()
    .transform(val => val || new Date().toISOString()),
  
  // ??? Dimensions (tags for grouping)
  dimensions: z.record(z.any())
    .optional()
    .default({})
    .refine(
      (obj) => JSON.stringify(obj).length <= 8192, // 8KB limit
      { message: 'Dimensions too large (max 8KB when serialized)' }
    ),
  
  // ?? Additional metadata
  metadata: z.record(z.any())
    .optional()
    .default({})
    .refine(
      (obj) => JSON.stringify(obj).length <= 16384, // 16KB limit
      { message: 'Metadata too large (max 16KB when serialized)' }
    )
});

/**
 * Batch metrics payload schema
 * Allows sending multiple metrics at once
 */
const batchMetricsSchema = z.object({
  metrics: z.array(metricPayloadSchema)
    .min(1, 'At least one metric required')
    .max(1000, 'Maximum 1000 metrics per batch'),
  
  batch_id: z.string()
    .uuid('Invalid UUID format for batch_id')
    .optional()
});

/**
 * Common metric names for validation
 */
const COMMON_METRICS = {
  // System metrics
  'system.cpu.usage': { unit: 'percent', min: 0, max: 100 },
  'system.memory.usage': { unit: 'bytes', min: 0 },
  'system.disk.usage': { unit: 'bytes', min: 0 },
  'system.network.rx': { unit: 'bytes_per_second', min: 0 },
  'system.network.tx': { unit: 'bytes_per_second', min: 0 },
  
  // Application metrics
  'app.request.count': { unit: 'count', min: 0 },
  'app.request.duration': { unit: 'milliseconds', min: 0 },
  'app.error.count': { unit: 'count', min: 0 },
  'app.active.users': { unit: 'count', min: 0 },
  
  // Business metrics
  'business.revenue': { unit: 'currency', min: 0 },
  'business.conversion.rate': { unit: 'percent', min: 0, max: 100 },
  'business.user.signups': { unit: 'count', min: 0 }
};

/**
 * Validate metric value against known metric types
 */
function validateMetricValue(metricName: string, value: number): {
  isValid: boolean;
  error?: string;
} {
  const knownMetric = COMMON_METRICS[metricName as keyof typeof COMMON_METRICS];
  
  if (!knownMetric) {
    // Unknown metric, allow any value
    return { isValid: true };
  }
  
  if (knownMetric.min !== undefined && value < knownMetric.min) {
    return {
      isValid: false,
      error: `${metricName} value must be >= ${knownMetric.min}`
    };
  }
  /*
  if (knownMetric.max !== undefined && value > knownMetric.max) {
    return {
      isValid: false,
      error: `${metricName} value must be <= ${knownMetric.max}`
    };
  }*/
  
  return { isValid: true };
}

/**
 * Store metric in database
 */
async function storeMetric(metric: any, correlationId: string): Promise<any> {
  const insertQuery = `
    INSERT INTO metrics (
      timestamp, metric_name, metric_value, metric_unit,
      service, tenant_name, hostname, dimensions, metadata,
      retention_until, created_at
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9,
      NOW() + INTERVAL '90 days', NOW()
    )
    RETURNING id, created_at, retention_until
  `;
  
  const values = [
    new Date(metric.timestamp),
    metric.metric_name,
    metric.metric_value,
    metric.metric_unit || null,
    metric.service,
    metric.tenant_name || null,
    metric.hostname || null,
    JSON.stringify(metric.dimensions || {}),
    JSON.stringify(metric.metadata || {})
  ];
  
  const result = await db.query(insertQuery, values, correlationId);
  return result.rows[0];
}

/**
 * Nuclear metrics ingestion endpoint
 * POST /api/metrics
 */
export const receiveMetrics = async (req: Request, res: Response): Promise<void> => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || 'unknown';
  const clientIp = req.ip || 'unknown';
  
  try {
    // ?? STEP 1: Determine if batch or single metric
    const isBatch = Array.isArray(req.body.metrics);
    
    logger.info('?? Metrics ingestion started', {
      classification: 'INTERNAL',
      audit_event: 'METRICS_INGESTION_STARTED',
      is_batch: isBatch,
      correlation_id: correlationId,
      client_ip: clientIp
    });
    
    let metricsToProcess: any[] = [];
    let batchId: string | undefined;
    
    // ?? STEP 2: Validate input
    if (isBatch) {
      const batchValidation = batchMetricsSchema.safeParse(req.body);
      
      if (!batchValidation.success) {
        const errors = batchValidation.error.errors;
        
        logger.warn('?? Batch metrics validation failed', {
          classification: 'HIGH',
          audit_event: 'METRICS_VALIDATION_FAILED',
          error_count: errors.length,
          errors: errors.map(e => ({ field: e.path.join('.'), message: e.message })),
          correlation_id: correlationId
        });
        
        res.status(400).json({
          error: 'Invalid metrics batch',
          details: errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          })),
          correlation_id: correlationId
        });
        return;
      }
      
      metricsToProcess = batchValidation.data.metrics;
      batchId = batchValidation.data.batch_id;
    } else {
      // Single metric
      const singleValidation = metricPayloadSchema.safeParse(req.body);
      
      if (!singleValidation.success) {
        const errors = singleValidation.error.errors;
        
        logger.warn('?? Metric validation failed', {
          classification: 'HIGH',
          audit_event: 'METRICS_VALIDATION_FAILED',
          error_count: errors.length,
          errors: errors.map(e => ({ field: e.path.join('.'), message: e.message })),
          correlation_id: correlationId
        });
        
        res.status(400).json({
          error: 'Invalid metric payload',
          details: errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          })),
          correlation_id: correlationId
        });
        return;
      }
      
      metricsToProcess = [singleValidation.data];
    }
    
    // ??? STEP 3: Validate metric values
    const validationErrors: any[] = [];
    
    for (const metric of metricsToProcess) {
      const valueValidation = validateMetricValue(metric.metric_name, metric.metric_value);
      if (!valueValidation.isValid) {
        validationErrors.push({
          metric_name: metric.metric_name,
          error: valueValidation.error
        });
      }
    }
    
    if (validationErrors.length > 0) {
      res.status(400).json({
        error: 'Invalid metric values',
        details: validationErrors,
        correlation_id: correlationId
      });
      return;
    }
    
    // ??? STEP 4: Store metrics in database
    const results = [];
    const errors = [];
    
    // Use transaction for batch processing
    if (isBatch && metricsToProcess.length > 1) {
      await db.withTransaction(async (client) => {
        for (const metric of metricsToProcess) {
          try {
            const result = await storeMetric(metric, correlationId);
            results.push({
              metric_name: metric.metric_name,
              id: result.id,
              status: 'stored'
            });
          } catch (error) {
            errors.push({
              metric_name: metric.metric_name,
              error: error instanceof Error ? error.message : String(error)
            });
          }
        }
      }, correlationId);
    } else {
      // Single metric, no transaction needed
      try {
        const result = await storeMetric(metricsToProcess[0], correlationId);
        results.push({
          metric_name: metricsToProcess[0].metric_name,
          id: result.id,
          status: 'stored'
        });
      } catch (error) {
        errors.push({
          metric_name: metricsToProcess[0].metric_name,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const duration = Date.now() - startTime;
    
    // ?? STEP 5: Audit logging
    nuclearAuditLogger.logEvent(
      'DATA_CREATED' as any,
      `Metrics ingestion completed`,
      errors.length === 0 ? 'SUCCESS' : 'PARTIAL',
      {
        resource_type: 'metrics',
        resource_id: batchId || results[0]?.id,
        tenant_name: metricsToProcess[0]?.tenant_name,
        metadata: {
          metrics_count: metricsToProcess.length,
          successful_count: results.length,
          failed_count: errors.length,
          is_batch: isBatch,
          batch_id: batchId,
          processing_time_ms: duration
        }
      }
    );
    
    // ?? STEP 6: Response
    const response: any = {
      status: errors.length === 0 ? 'success' : 'partial_success',
      message: `${results.length} metrics stored successfully`,
      correlation_id: correlationId,
      processing_time_ms: duration
    };
    
    if (isBatch) {
      response.batch_id = batchId;
      response.results = results;
      if (errors.length > 0) {
        response.errors = errors;
      }
    } else {
      response.metric_id = results[0]?.id;
    }
    
    res.status(errors.length === 0 ? 201 : 207).json(response);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('?? Metrics ingestion failed', {
      classification: 'CRITICAL',
      audit_event: 'METRICS_INGESTION_FAILED',
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      correlation_id: correlationId,
      client_ip: clientIp,
      duration_ms: duration
    });
    
    res.status(500).json({
      error: 'Internal server error during metrics ingestion',
      correlation_id: correlationId
    });
  }
};

/**
 * Get metrics health status
 * GET /api/metrics/health
 */
export const metricsHealthCheck = async (req: Request, res: Response): Promise<void> => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  try {
    // Test database connectivity
    const dbHealthQuery = `
      SELECT 
        COUNT(*) as total_metrics,
        MIN(timestamp) as oldest_metric,
        MAX(timestamp) as newest_metric
      FROM metrics
      WHERE created_at > NOW() - INTERVAL '1 hour'
    `;
    
    const dbResult = await db.query(dbHealthQuery);
    const stats = dbResult.rows[0];
    
    const healthStatus = {
      status: 'healthy',
      service: 'metrics-ingestion',
      timestamp: new Date().toISOString(),
      database: {
        status: 'connected',
        recent_metrics: parseInt(stats.total_metrics),
        oldest_metric: stats.oldest_metric,
        newest_metric: stats.newest_metric
      },
      supported_metrics: Object.keys(COMMON_METRICS),
      endpoints: {
        receive_metrics: 'POST /api/metrics',
        batch_metrics: 'POST /api/metrics (with metrics array)',
        health: 'GET /api/metrics/health'
      },
      limits: {
        max_batch_size: 1000,
        retention_days: 90
      },
      correlation_id: correlationId
    };
    
    res.status(200).json(healthStatus);
    
  } catch (error) {
    logger.error('?? Metrics health check failed', {
      classification: 'HIGH',
      audit_event: 'METRICS_HEALTH_CHECK_FAILED',
      error: error instanceof Error ? error.message : String(error),
      correlation_id: correlationId
    });
    
    res.status(503).json({
      status: 'unhealthy',
      service: 'metrics-ingestion',
      timestamp: new Date().toISOString(),
      error: 'Service health check failed',
      correlation_id: correlationId
    });
  }
};
// src/middlewares/auditLogger.ts
/**
 * üö® CORE-BACKEND: Nuclear Audit Logger Middleware
 * 
 * Comprehensive audit trail middleware for compliance
 * Implements ISO 27001 A.12.4.1 comprehensive event logging
 * 
 * Classification: CONFIDENTIAL (audit infrastructure)
 * Retention: 7 years (regulatory requirement)
 * Review Date: Every 3 months (critical compliance component)
 */

import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';
import logger from '../utils/logger';

/**
 * Audit event types for compliance categorization
 */
export enum AuditEventType {
  // Authentication events
  AUTH_SUCCESS = 'AUTH_SUCCESS',
  AUTH_FAILURE = 'AUTH_FAILURE',
  AUTH_LOGOUT = 'AUTH_LOGOUT',
  TOKEN_GENERATED = 'TOKEN_GENERATED',
  TOKEN_VALIDATED = 'TOKEN_VALIDATED',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  
  // Authorization events
  ACCESS_GRANTED = 'ACCESS_GRANTED',
  ACCESS_DENIED = 'ACCESS_DENIED',
  PERMISSION_ESCALATION = 'PERMISSION_ESCALATION',
  
  // Data processing events
  DATA_CREATED = 'DATA_CREATED',
  DATA_ACCESSED = 'DATA_ACCESSED',
  DATA_MODIFIED = 'DATA_MODIFIED',
  DATA_DELETED = 'DATA_DELETED',
  DATA_EXPORTED = 'DATA_EXPORTED',
  
  // Log processing events
  LOG_INGESTED = 'LOG_INGESTED',
  LOG_VALIDATED = 'LOG_VALIDATED',
  LOG_CLASSIFIED = 'LOG_CLASSIFIED',
  LOG_RETENTION_APPLIED = 'LOG_RETENTION_APPLIED',
  
  // System events
  SERVICE_STARTED = 'SERVICE_STARTED',
  SERVICE_STOPPED = 'SERVICE_STOPPED',
  CONFIG_CHANGED = 'CONFIG_CHANGED',
  ERROR_OCCURRED = 'ERROR_OCCURRED',
  
  // Security events
  SECURITY_VIOLATION = 'SECURITY_VIOLATION',
  ATTACK_DETECTED = 'ATTACK_DETECTED',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  SUSPICIOUS_ACTIVITY = 'SUSPICIOUS_ACTIVITY',
  
  // Compliance events
  GDPR_REQUEST = 'GDPR_REQUEST',
  DATA_RETENTION_CLEANUP = 'DATA_RETENTION_CLEANUP',
  COMPLIANCE_VALIDATION = 'COMPLIANCE_VALIDATION',
  AUDIT_LOG_ACCESS = 'AUDIT_LOG_ACCESS'
}

/**
 * Audit log entry interface
 * Structured format for comprehensive audit trails
 */
interface AuditLogEntry {
  // Core audit fields (ISO 27001 A.12.4.1)
  event_type: AuditEventType;
  timestamp: string;
  correlation_id: string;
  
  // Subject (who)
  user_id?: string;
  user_role?: string;
  service_account?: string;
  
  // Object (what)
  resource_type?: string;
  resource_id?: string;
  tenant_name?: string;
  
  // Action (what happened)
  action: string;
  outcome: 'SUCCESS' | 'FAILURE' | 'PARTIAL';
  
  // Context (how/where/when)
  source_ip?: string;
  user_agent?: string;
  session_id?: string;
  request_id?: string;
  
  // Technical details
  method?: string;
  endpoint?: string;
  status_code?: number;
  duration_ms?: number;
  
  // Security context
  classification?: string;
  risk_score?: number;
  threat_indicators?: string[];
  
  // Compliance context
  data_categories?: string[];
  legal_basis?: string;
  retention_period?: number;
  
  // Additional metadata
  metadata?: Record<string, any>;
}

/**
 * Risk scoring for audit events
 * Helps prioritize security investigations
 */
function calculateRiskScore(
  eventType: AuditEventType,
  outcome: string,
  context: any
): number {
  let score = 0;
  
  // Base score by event type
  switch (eventType) {
    case AuditEventType.AUTH_FAILURE:
    case AuditEventType.ACCESS_DENIED:
      score += 3;
      break;
    case AuditEventType.SECURITY_VIOLATION:
    case AuditEventType.ATTACK_DETECTED:
      score += 8;
      break;
    case AuditEventType.DATA_DELETED:
    case AuditEventType.DATA_EXPORTED:
      score += 5;
      break;
    case AuditEventType.PERMISSION_ESCALATION:
      score += 6;
      break;
    default:
      score += 1;
  }
  
  // Failure increases risk
  if (outcome === 'FAILURE') {
    score += 2;
  }
  
  // Multiple failures from same IP
  if (context.repeated_failures > 3) {
    score += 3;
  }
  
  // Suspicious patterns
  if (context.off_hours) {
    score += 1;
  }
  
  if (context.unusual_location) {
    score += 2;
  }
  
  return Math.min(score, 10); // Cap at 10
}

/**
 * Detect threat indicators from request context
 */
function detectThreatIndicators(req: Request, eventType: AuditEventType): string[] {
  const indicators: string[] = [];
  
  // SQL injection patterns in query/body
  const sqlPatterns = /(\bSELECT\b|\bUNION\b|\bDROP\b|\bINSERT\b|\bUPDATE\b|\bDELETE\b)/i;
  const requestData = JSON.stringify({ query: req.query, body: req.body });
  
  if (sqlPatterns.test(requestData)) {
    indicators.push('SQL_INJECTION_PATTERN');
  }
  
  // XSS patterns
  const xssPatterns = /<script|javascript:|on\w+=/i;
  if (xssPatterns.test(requestData)) {
    indicators.push('XSS_PATTERN');
  }
  
  // Path traversal
  const pathTraversalPatterns = /\.\.\/|\.\.\\|%2e%2e/i;
  if (pathTraversalPatterns.test(req.originalUrl || '')) {
    indicators.push('PATH_TRAVERSAL_PATTERN');
  }
  
  // Unusual user agents
  const userAgent = req.headers['user-agent'] || '';
  if (userAgent.includes('sqlmap') || userAgent.includes('nmap') || userAgent.includes('nikto')) {
    indicators.push('ATTACK_TOOL_USER_AGENT');
  }
  
  // Rapid requests (if we tracked this)
  if ((req as any).rapidRequests > 10) {
    indicators.push('RAPID_REQUESTS');
  }
  
  // Authentication without proper headers
  if (eventType === AuditEventType.AUTH_FAILURE && !req.headers.authorization) {
    indicators.push('AUTH_WITHOUT_HEADER');
  }
  
  return indicators;
}

/**
 * Audit logger class for comprehensive event logging
 */
class NuclearAuditLogger {
  
  /**
   * Log audit event with comprehensive context
   */
  logEvent(
    eventType: AuditEventType,
    action: string,
    outcome: 'SUCCESS' | 'FAILURE' | 'PARTIAL',
    context: Partial<AuditLogEntry> = {}
  ): void {
    
    const timestamp = new Date().toISOString();
    const correlationId = context.correlation_id || uuidv4();
    
    // Calculate risk score
    const riskScore = calculateRiskScore(eventType, outcome, context);
    
    // Build comprehensive audit entry
    const auditEntry: AuditLogEntry = {
      event_type: eventType,
      timestamp,
      correlation_id: correlationId,
      action,
      outcome,
      risk_score: riskScore,
      ...context
    };
    
    // Determine log classification based on event type and risk
    let classification: 'PUBLIC' | 'INTERNAL' | 'HIGH' | 'CONFIDENTIAL' | 'CRITICAL' = 'INTERNAL';
    if (riskScore >= 7) {
      classification = 'CRITICAL';
    } else if (riskScore >= 4 || eventType.includes('SECURITY') || eventType.includes('AUTH')) {
      classification = 'HIGH';
    } else if (eventType.includes('DATA')) {
      classification = 'CONFIDENTIAL';
    }
    
    // Build comprehensive audit entry (without correlation_id and classification to avoid conflicts)
    const { correlation_id: _, classification: __, ...auditEntryWithoutConflicts } = auditEntry;
    
    // Log with appropriate classification
    logger.audit(eventType, `${action} - ${outcome}`, {
      classification,
      correlation_id: correlationId,
      risk_score: riskScore,
      ...auditEntryWithoutConflicts
    });
    
    // Enhanced logging for high-risk events
    if (riskScore >= 6) {
      logger.security('üö® High-risk audit event detected', {
        correlation_id: correlationId,
        event_type: eventType,
        risk_score: riskScore,
        action,
        outcome,
        threat_indicators: context.threat_indicators
      });
    }
  }
  
  /**
   * Log authentication event
   */
  logAuthEvent(
    success: boolean,
    username: string,
    req: Request,
    additionalContext: any = {}
  ): void {
    const eventType = success ? AuditEventType.AUTH_SUCCESS : AuditEventType.AUTH_FAILURE;
    const outcome = success ? 'SUCCESS' : 'FAILURE';
    
    this.logEvent(eventType, `User authentication for ${username}`, outcome, {
      correlation_id: (req as any).correlationId,
      user_id: username,
      source_ip: req.ip,
      user_agent: req.headers['user-agent'],
      method: req.method,
      endpoint: req.originalUrl,
      threat_indicators: detectThreatIndicators(req, eventType),
      ...additionalContext
    });
  }
  
  /**
   * Log data access event
   */
  logDataAccess(
    resourceType: string,
    resourceId: string,
    action: string,
    req: Request,
    success: boolean = true,
    additionalContext: any = {}
  ): void {
    const outcome = success ? 'SUCCESS' : 'FAILURE';
    
    this.logEvent(AuditEventType.DATA_ACCESSED, `${action} ${resourceType}`, outcome, {
      correlation_id: (req as any).correlationId,
      resource_type: resourceType,
      resource_id: resourceId,
      user_id: (req as any).user?.username,
      tenant_name: (req as any).tenantName,
      source_ip: req.ip,
      method: req.method,
      endpoint: req.originalUrl,
      ...additionalContext
    });
  }
  
  /**
   * Log log ingestion event (meta!)
   */
  logLogIngestion(
    tenantName: string,
    classification: string,
    req: Request,
    success: boolean = true,
    additionalContext: any = {}
  ): void {
    const outcome = success ? 'SUCCESS' : 'FAILURE';
    
    this.logEvent(AuditEventType.LOG_INGESTED, `Log ingestion for ${tenantName}`, outcome, {
      correlation_id: (req as any).correlationId,
      tenant_name: tenantName,
      classification,
      user_id: (req as any).user?.username,
      source_ip: req.ip,
      method: req.method,
      endpoint: req.originalUrl,
      data_categories: ['log_data'],
      legal_basis: 'legitimate_interest',
      ...additionalContext
    });
  }
}

// Create singleton audit logger instance
const nuclearAuditLogger = new NuclearAuditLogger();

/**
 * Express middleware for automatic request auditing
 * Logs all requests with comprehensive context
 */
export const auditLoggerMiddleware = (req: Request, res: Response, next: NextFunction): void => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || uuidv4();
  
  // Store correlation ID if not already present
  (req as any).correlationId = correlationId;
  
  // Log request start
  nuclearAuditLogger.logEvent(
    AuditEventType.DATA_ACCESSED,
    `HTTP request to ${req.method} ${req.originalUrl}`,
    'SUCCESS',
    {
      correlation_id: correlationId,
      method: req.method,
      endpoint: req.originalUrl,
      source_ip: req.ip,
      user_agent: req.headers['user-agent'],
      user_id: (req as any).user?.username || 'anonymous',
      tenant_name: (req as any).tenantName,
      threat_indicators: detectThreatIndicators(req, AuditEventType.DATA_ACCESSED)
    }
  );
  
  // Capture response
  const originalEnd = res.end.bind(res);
  (res as any).end = (...args: any[]) => {
    const duration = Date.now() - startTime;
    
    // Log request completion
    nuclearAuditLogger.logEvent(
      AuditEventType.DATA_ACCESSED,
      `HTTP request completed ${req.method} ${req.originalUrl}`,
      res.statusCode < 400 ? 'SUCCESS' : 'FAILURE',
      {
        correlation_id: correlationId,
        method: req.method,
        endpoint: req.originalUrl,
        status_code: res.statusCode,
        duration_ms: duration,
        source_ip: req.ip,
        user_id: (req as any).user?.username || 'anonymous'
      }
    );
    
    return originalEnd(...args);
  };
  
  next();
};

// Export instance and default
export { nuclearAuditLogger };
export default nuclearAuditLogger;
// src/middlewares/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// Secret key used to sign and verify JWTs
const SECRET = process.env.JWT_SECRET || 'default_secret_dangerous';

// Middleware to authenticate requests using JWT
export const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
  // Read the Authorization header from the request
  const authHeader = req.headers.authorization;

  // Check if the header exists and follows the Bearer token format
  if (authHeader && authHeader.startsWith('Bearer ')) {
    // Extract the token from the header
    const token = authHeader.split(' ')[1];

    // Verify the token using the configured secret
    jwt.verify(token, SECRET, (err, user) => {
      if (err) {
        // Token is invalid or expired
        return res.status(403).json({ error: 'Invalid or expired token' });
      }

      // Token is valid; attach user info to the request object
      (req as any).user = user;

      // Proceed to the next middleware or route handler
      next();
    });
  } else {
    // Authorization header is missing or not formatted correctly
    return res.status(401).json({ error: 'Authorization header missing or malformed' });
  }
};

// src/middlewares/authenticateJWT.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import config from '../config/envConfig';

// Extend Express Request interface to include 'user'
declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

export function authenticateJWT(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid token' });
  }

  const token = authHeader.split(' ')[1];

  try {
    if (!config.jwtSecret) {
      return res.status(500).json({ error: 'JWT secret is not configured' });
    }
    const payload = jwt.verify(token, config.jwtSecret as string);
    req.user = payload;
    next();
  } catch (err) {
    return res.status(403).json({ error: 'Invalid token' });
  }
}

// src/middlewares/authentication.ts
/**
 * üö® CORE-BACKEND: Nuclear Authentication Middleware
 * 
 * Zero Trust Authentication Implementation
 * Compliance: Never Trust, Always Verify
 * 
 * Classification: CONFIDENTIAL (authentication logic)
 * Retention: 7 years (security requirement)
 * Review Date: Every 3 months
 */

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import config from '../config/envConfig';
import logger from '../utils/logger';
import nuclearAuditLogger from './auditLogger';

/**
 * Extended Request interface with authenticated user
 */
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    tenant_name: string;
    roles: string[];
    permissions: string[];
    session_id: string;
    iat: number;
    exp: number;
  };
  correlation_id?: string;
}

/**
 * JWT Token payload interface
 */
interface JWTPayload {
  sub: string; // user id
  tenant_name: string;
  roles: string[];
  permissions: string[];
  session_id: string;
  iat: number;
  exp: number;
}

/**
 * Authentication error with security context
 */
export class AuthenticationError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly httpStatus: number = 401
  ) {
    super(message);
    this.name = 'AuthenticationError';
  }
}

/**
 * Nuclear authentication middleware
 * Implements Zero Trust "Never Trust, Always Verify" principle
 */
export function authenticateRequest(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void {
  const startTime = Date.now();
  const correlationId = req.headers['x-correlation-id'] as string || generateCorrelationId();
  req.correlation_id = correlationId;
  
  try {
    // üîç STEP 1: Extract and validate token
    const token = extractToken(req);
    if (!token) {
      throw new AuthenticationError(
        'Authentication token required',
        'TOKEN_MISSING'
      );
    }
    
    // üîê STEP 2: Verify JWT signature and claims
    const payload = verifyToken(token);
    
    // üõ°Ô∏è STEP 3: Validate token claims
    validateTokenClaims(payload);
    
    // üë§ STEP 4: Attach user context to request
    req.user = {
      id: payload.sub,
      tenant_name: payload.tenant_name,
      roles: payload.roles,
      permissions: payload.permissions,
      session_id: payload.session_id,
      iat: payload.iat,
      exp: payload.exp
    };
    
    // üìä STEP 5: Log successful authentication
    const duration = Date.now() - startTime;
    
    logger.info('üîê Authentication successful', {
      classification: 'CONFIDENTIAL',
      audit_event: 'AUTHENTICATION_SUCCESS',
      user_id: payload.sub,
      tenant_name: payload.tenant_name,
      session_id: payload.session_id,
      correlation_id: correlationId,
      duration_ms: duration,
      ip_address: getClientIP(req),
      user_agent: req.headers['user-agent']
    });
    
    // Audit log for compliance
    nuclearAuditLogger.logEvent(
      'AUTH_SUCCESS' as any,
      'User successfully authenticated',
      'SUCCESS',
      {
        resource_type: 'authentication',
        resource_id: payload.sub,
        metadata: {
          tenant_name: payload.tenant_name,
          session_id: payload.session_id,
          correlation_id: correlationId,
          roles: payload.roles,
          ip_address: getClientIP(req),
          duration_ms: duration
        }
      }
    );
    
    next();
    
  } catch (error) {
    handleAuthenticationError(error, req, res, correlationId);
  }
}

/**
 * Extract Bearer token from Authorization header
 */
function extractToken(req: Request): string | null {
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    return null;
  }
  
  const matches = authHeader.match(/^Bearer\s+(.+)$/);
  return matches ? matches[1] : null;
}

/**
 * Verify JWT token signature and decode payload
 */
function verifyToken(token: string): JWTPayload {
  try {
    const decoded = jwt.verify(token, config.jwtSecret) as JWTPayload;
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new AuthenticationError(
        'Authentication token expired',
        'TOKEN_EXPIRED'
      );
    } else if (error instanceof jwt.JsonWebTokenError) {
      throw new AuthenticationError(
        'Invalid authentication token',
        'TOKEN_INVALID'
      );
    } else {
      throw new AuthenticationError(
        'Token verification failed',
        'TOKEN_VERIFICATION_FAILED'
      );
    }
  }
}

/**
 * Validate token claims for security requirements
 */
function validateTokenClaims(payload: JWTPayload): void {
  // Validate required claims
  if (!payload.sub) {
    throw new AuthenticationError(
      'Token missing user identifier',
      'TOKEN_MISSING_USER_ID'
    );
  }
  
  if (!payload.tenant_name) {
    throw new AuthenticationError(
      'Token missing tenant identifier',
      'TOKEN_MISSING_TENANT'
    );
  }
  
  if (!payload.session_id) {
    throw new AuthenticationError(
      'Token missing session identifier',
      'TOKEN_MISSING_SESSION'
    );
  }
  
  if (!Array.isArray(payload.roles)) {
    throw new AuthenticationError(
      'Token missing or invalid roles',
      'TOKEN_INVALID_ROLES'
    );
  }
  
  if (!Array.isArray(payload.permissions)) {
    throw new AuthenticationError(
      'Token missing or invalid permissions',
      'TOKEN_INVALID_PERMISSIONS'
    );
  }
  
  // Validate token is not too old (security best practice)
  const tokenAge = Date.now() / 1000 - payload.iat;
  const maxTokenAge = 24 * 60 * 60; // 24 hours
  
  if (tokenAge > maxTokenAge) {
    throw new AuthenticationError(
      'Token too old, re-authentication required',
      'TOKEN_TOO_OLD'
    );
  }
}

/**
 * Handle authentication errors with comprehensive logging
 */
function handleAuthenticationError(
  error: unknown,
  req: AuthenticatedRequest,
  res: Response,
  correlationId: string
): void {
  const authError = error instanceof AuthenticationError 
    ? error 
    : new AuthenticationError('Authentication failed', 'UNKNOWN_ERROR');
  
  // Log authentication failure
  logger.warn('üö´ Authentication failed', {
    classification: 'HIGH',
    audit_event: 'AUTHENTICATION_FAILED',
    error_code: authError.code,
    error_message: authError.message,
    correlation_id: correlationId,
    ip_address: getClientIP(req),
    user_agent: req.headers['user-agent'],
    path: req.path,
    method: req.method
  });
  
  // Audit log for security monitoring
  nuclearAuditLogger.logEvent(
    'AUTH_FAILURE' as any,
    'Authentication attempt failed',
    'FAILURE',
    {
      resource_type: 'authentication',
      resource_id: 'unknown',
      metadata: {
        error_code: authError.code,
        correlation_id: correlationId,
        ip_address: getClientIP(req),
        path: req.path,
        method: req.method,
        security_impact: 'POTENTIAL_UNAUTHORIZED_ACCESS'
      }
    }
  );
  
  // Return standardized error response
  res.status(authError.httpStatus).json({
    error: 'Authentication Required',
    message: 'Valid authentication token required',
    code: authError.code,
    correlation_id: correlationId,
    timestamp: new Date().toISOString()
  });
}

/**
 * Get client IP address with proxy support
 */
function getClientIP(req: Request): string {
  return (
    req.headers['x-forwarded-for'] as string ||
    req.headers['x-real-ip'] as string ||
    req.connection.remoteAddress ||
    req.socket.remoteAddress ||
    'unknown'
  );
}

/**
 * Generate correlation ID for request tracking
 */
function generateCorrelationId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Optional middleware for API key authentication (alternative to JWT)
 */
export function authenticateAPIKey(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void {
  const apiKey = req.headers['x-api-key'] as string;
  const correlationId = req.headers['x-correlation-id'] as string || generateCorrelationId();
  req.correlation_id = correlationId;
  
  if (!apiKey) {
    return handleAuthenticationError(
      new AuthenticationError('API key required', 'API_KEY_MISSING'),
      req,
      res,
      correlationId
    );
  }
  
  // In a real implementation, validate API key against database
  // For now, just check it's not empty and has minimum length
  if (apiKey.length < 32) {
    return handleAuthenticationError(
      new AuthenticationError('Invalid API key format', 'API_KEY_INVALID'),
      req,
      res,
      correlationId
    );
  }
  
  // Attach minimal user context for API key auth
  req.user = {
    id: 'api-key-user',
    tenant_name: 'api-tenant', // Should be derived from API key
    roles: ['api'],
    permissions: ['read', 'write'],
    session_id: correlationId,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600 // 1 hour
  };
  
  logger.info('üîë API key authentication successful', {
    classification: 'CONFIDENTIAL',
    audit_event: 'API_KEY_AUTHENTICATION_SUCCESS',
    correlation_id: correlationId,
    ip_address: getClientIP(req)
  });
  
  next();
}

/**
 * Middleware to skip authentication for health checks
 */
export function skipAuthForHealthCheck(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Skip authentication for health check endpoints
  if (req.path === '/health' || req.path === '/ping' || req.path === '/status') {
    return next();
  }
  
  // Apply authentication for all other routes
  return authenticateRequest(req as AuthenticatedRequest, res, next);
}
// src/middlewares/authorizeAdmin.ts
// Middleware to enforce that only users with role "admin" can access a route
import { Request, Response, NextFunction } from 'express';

export const authorizeAdmin = (req: Request, res: Response, next: NextFunction) => {
  const user = (req as any).user;

  if (!user || user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden: admin access required' });
  }

  next();
};

// src/middlewares/errorHandler.ts
/**
 * üö® CORE-BACKEND: Nuclear Error Handler
 * 
 * Comprehensive error handling with security and compliance logging
 * Implements defense-in-depth error management strategy
 * 
 * Classification: CONFIDENTIAL (error handling logic)
 * Retention: 7 years (security requirement)
 * Review Date: Every 3 months (critical security component)
 */

import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

/**
 * Error categories for classification and response handling
 */
enum ErrorCategory {
  VALIDATION = 'VALIDATION',
  AUTHENTICATION = 'AUTHENTICATION', 
  AUTHORIZATION = 'AUTHORIZATION',
  NOT_FOUND = 'NOT_FOUND',
  RATE_LIMIT = 'RATE_LIMIT',
  DATABASE = 'DATABASE',
  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',
  SYSTEM = 'SYSTEM',
  UNKNOWN = 'UNKNOWN'
}

/**
 * Error severity levels for compliance and monitoring
 */
enum ErrorSeverity {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM', 
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL'
}

/**
 * Enhanced error interface with security context
 */
interface EnhancedError extends Error {
  statusCode?: number;
  category?: ErrorCategory;
  severity?: ErrorSeverity;
  correlationId?: string;
  userContext?: {
    user_id?: string;
    ip_address?: string;
    user_agent?: string;
  };
  securityContext?: {
    is_attack?: boolean;
    attack_type?: string;
    blocked?: boolean;
  };
}

/**
 * Categorize error based on properties and context
 */
function categorizeError(error: any, req: Request): {
  category: ErrorCategory;
  severity: ErrorSeverity;
  statusCode: number;
  securityRelevant: boolean;
} {
  // Handle known error types
  if (error.name === 'ValidationError' || error.statusCode === 400) {
    return {
      category: ErrorCategory.VALIDATION,
      severity: ErrorSeverity.MEDIUM,
      statusCode: 400,
      securityRelevant: true
    };
  }
  
  if (error.statusCode === 401 || error.name === 'UnauthorizedError') {
    return {
      category: ErrorCategory.AUTHENTICATION,
      severity: ErrorSeverity.HIGH,
      statusCode: 401,
      securityRelevant: true
    };
  }
  
  if (error.statusCode === 403 || error.name === 'ForbiddenError') {
    return {
      category: ErrorCategory.AUTHORIZATION,
      severity: ErrorSeverity.HIGH,
      statusCode: 403,
      securityRelevant: true
    };
  }
  
  if (error.statusCode === 404 || error.name === 'NotFoundError') {
    return {
      category: ErrorCategory.NOT_FOUND,
      severity: ErrorSeverity.LOW,
      statusCode: 404,
      securityRelevant: false
    };
  }
  
  if (error.statusCode === 429 || error.name === 'TooManyRequestsError') {
    return {
      category: ErrorCategory.RATE_LIMIT,
      severity: ErrorSeverity.HIGH,
      statusCode: 429,
      securityRelevant: true
    };
  }
  
  // Database errors
  if (error.code && (error.code.startsWith('23') || error.code.startsWith('42'))) {
    return {
      category: ErrorCategory.DATABASE,
      severity: ErrorSeverity.HIGH,
      statusCode: 500,
      securityRelevant: true
    };
  }
  
  // Network/timeout errors
  if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
    return {
      category: ErrorCategory.EXTERNAL_SERVICE,
      severity: ErrorSeverity.MEDIUM,
      statusCode: 503,
      securityRelevant: false
    };
  }
  
  // System errors (5xx range)
  if (error.statusCode >= 500) {
    return {
      category: ErrorCategory.SYSTEM,
      severity: ErrorSeverity.CRITICAL,
      statusCode: error.statusCode,
      securityRelevant: false
    };
  }
  
  // Unknown errors
  return {
    category: ErrorCategory.UNKNOWN,
    severity: ErrorSeverity.CRITICAL,
    statusCode: 500,
    securityRelevant: true
  };
}

/**
 * Extract security context from request and error
 */
function extractSecurityContext(error: any, req: Request): {
  userContext: any;
  securityContext: any;
  requestContext: any;
} {
  const userContext = {
    user_id: (req as any).user?.username || 'anonymous',
    ip_address: req.ip || 'unknown',
    user_agent: req.headers['user-agent'] || 'unknown',
    tenant_name: (req as any).tenantName || 'unknown'
  };
  
  // Detect potential security issues
  const securityContext: {
    is_attack: boolean;
    attack_type: string | null;
    blocked: boolean;
  } = {
    is_attack: false,
    attack_type: null,
    blocked: false
  };
  
  // SQL injection patterns
  if (error.message && /(\bSELECT\b|\bUNION\b|\bDROP\b)/i.test(error.message)) {
    securityContext.is_attack = true;
    securityContext.attack_type = 'SQL_INJECTION_ATTEMPT';
  }
  
  // XSS patterns
  if (error.message && /<script|javascript:|on\w+=/i.test(error.message)) {
    securityContext.is_attack = true;
    securityContext.attack_type = 'XSS_ATTEMPT';
  }
  
  // Path traversal patterns
  if (error.message && /\.\.\/|\.\.\\/.test(error.message)) {
    securityContext.is_attack = true;
    securityContext.attack_type = 'PATH_TRAVERSAL_ATTEMPT';
  }
  
  const requestContext = {
    method: req.method,
    path: req.originalUrl || req.url,
    query_params: Object.keys(req.query).length > 0 ? req.query : undefined,
    content_length: req.headers['content-length'],
    referer: req.headers.referer
  };
  
  return { userContext, securityContext, requestContext };
}

/**
 * Sanitize error message for client response
 * Prevents information leakage while maintaining usability
 */
function sanitizeErrorMessage(error: any, category: ErrorCategory, isProduction: boolean): string {
  // In production, don't leak internal details
  if (isProduction) {
    switch (category) {
      case ErrorCategory.VALIDATION:
        return 'Invalid request data';
      case ErrorCategory.AUTHENTICATION:
        return 'Authentication required';
      case ErrorCategory.AUTHORIZATION:
        return 'Access denied';
      case ErrorCategory.NOT_FOUND:
        return 'Resource not found';
      case ErrorCategory.RATE_LIMIT:
        return 'Too many requests';
      case ErrorCategory.DATABASE:
        return 'Data processing error';
      case ErrorCategory.EXTERNAL_SERVICE:
        return 'Service temporarily unavailable';
      default:
        return 'Internal server error';
    }
  }
  
  // In development, provide more details
  return error.message || 'Unknown error occurred';
}

/**
 * Nuclear error handler middleware
 * Implements comprehensive error processing with security and compliance
 */
export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  const correlationId = (req as any).correlationId || 'unknown';
  const isProduction = process.env.NODE_ENV === 'production';
  
  try {
    // Categorize error
    const { category, severity, statusCode, securityRelevant } = categorizeError(err, req);
    
    // Extract context
    const { userContext, securityContext, requestContext } = extractSecurityContext(err, req);
    
    // Determine log classification based on severity
    const logClassification = severity === ErrorSeverity.CRITICAL ? 'CRITICAL' :
                             severity === ErrorSeverity.HIGH ? 'HIGH' :
                             securityRelevant ? 'HIGH' : 'INTERNAL';
    
    // Log error with comprehensive context
    logger.error('üí• Request error occurred', {
      classification: logClassification,
      audit_event: 'REQUEST_ERROR',
      correlation_id: correlationId,
      
      // Error details
      error: {
        category,
        severity,
        message: err.message,
        name: err.name,
        code: err.code,
        stack: isProduction ? undefined : err.stack // Don't log stack in production
      },
      
      // Security context
      security: securityContext,
      
      // User and request context
      user: userContext,
      request: requestContext,
      
      // Response context
      response: {
        status_code: statusCode,
        processing_time_ms: Date.now() - startTime
      }
    });
    
    // Enhanced logging for security events
    if (securityContext.is_attack) {
      logger.security('üö® Potential security attack detected', {
        correlation_id: correlationId,
        attack_type: securityContext.attack_type,
        user_context: userContext,
        request_context: requestContext,
        error_message: err.message
      });
    }
    
    // Enhanced logging for critical errors
    if (severity === ErrorSeverity.CRITICAL) {
      logger.audit('CRITICAL_ERROR', 'Critical system error occurred', {
        correlation_id: correlationId,
        category,
        error_message: err.message,
        user_context: userContext,
        system_impact: 'HIGH'
      });
    }
    
    // Prepare client response
    const clientMessage = sanitizeErrorMessage(err, category, isProduction);
    
    // Build response object
    const errorResponse: any = {
      status: 'error',
      message: clientMessage,
      correlation_id: correlationId,
      timestamp: new Date().toISOString()
    };
    
    // Add additional context in development
    if (!isProduction) {
      errorResponse.details = {
        category,
        original_message: err.message,
        path: req.originalUrl
      };
    }
    
    // Add retry guidance for temporary errors
    if (category === ErrorCategory.EXTERNAL_SERVICE || category === ErrorCategory.DATABASE) {
      errorResponse.retry_after = '30 seconds';
    }
    
    // Add rate limit info
    if (category === ErrorCategory.RATE_LIMIT) {
      errorResponse.retry_after = req.headers['retry-after'] || '60 seconds';
    }
    
    // Send response
    res.status(statusCode).json(errorResponse);
    
  } catch (handlerError) {
    // Error in error handler - log and fail gracefully
    logger.error('üí• CRITICAL: Error handler failure', {
      classification: 'CRITICAL',
      audit_event: 'ERROR_HANDLER_FAILURE',
      correlation_id: correlationId,
      original_error: err.message,
      handler_error: handlerError instanceof Error ? handlerError.message : String(handlerError),
      stack: handlerError instanceof Error ? handlerError.stack : undefined
    });
    
    // Last resort response
    res.status(500).json({
      status: 'error',
      message: 'Critical system error',
      correlation_id: correlationId,
      timestamp: new Date().toISOString()
    });
  }
};

/**
 * 404 Not Found handler
 * Handles requests to non-existent endpoints
 */
export const notFoundHandler = (req: Request, res: Response): void => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  logger.warn('üö´ Endpoint not found', {
    classification: 'INTERNAL',
    audit_event: 'ENDPOINT_NOT_FOUND',
    correlation_id: correlationId,
    method: req.method,
    path: req.originalUrl,
    client_ip: req.ip,
    user_agent: req.headers['user-agent']
  });
  
  res.status(404).json({
    status: 'error',
    message: 'Endpoint not found',
    correlation_id: correlationId,
    timestamp: new Date().toISOString(),
    available_endpoints: [
      'GET /health',
      'POST /auth/login',
      'POST /api/emit-log'
    ]
  });
};

/**
 * Async error wrapper for route handlers
 * Catches async errors and passes to error handler
 */
export const asyncErrorHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
// src/middlewares/rateLimiter.ts
// middlewares/rateLimiter.ts
import rateLimit from 'express-rate-limit';

export const rateLimiter = rateLimit({
  windowMs: 60 * 1000,        // 1 minute
  max: 100,                   // m√°x 100 requests per minute per IP
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many requests, please try again later.'
});

export const loginLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 10,                   // only 10 login attempts per minute
  message: 'Too many login attempts. Please try again in 1 minutes.'
});

// src/routes/appRoutes.ts
import express from "express";
import { generateLogEmitter } from "../controllers/log/emitter";
import { authenticateJWT } from "../middlewares/auth";
import { authorizeAdmin } from "../middlewares/authorizeAdmin";
import { receiveMetrics } from "../controllers/metrics/receive";
//import { receiveHeartbeat } from "../controllers/heartbeat/receive";

const configureRouter = (app: express.Application) => {
  app.get("/health", (req, res) => {
    res.status(200).json({ status: "ok", timestamp: new Date().toISOString() });
  });

  // Define the routes for PDF, ZPL, email, and log generation
  // These routes are protected by JWT authentication and admin authorization
  // The authenticateJWT middleware checks the JWT token in the request header
  // The authorizeAdmin middleware checks if the user has admin privileges


  // Route to emit logs
  app.post("/emit-log", authenticateJWT, authorizeAdmin, generateLogEmitter);

  // Route to receive metrics
  // This route allows clients to send metrics data to the server
  // The receiveMetrics controller processes the incoming metrics data
  app.post("/api/metrics", authenticateJWT, authorizeAdmin, receiveMetrics);

  // Route to receive heartbeat signals
  // This route allows services to send heartbeat signals to the server
  // The receiveHeartbeat controller processes the incoming heartbeat data
  //app.post("/api/heartbeat", authenticateJWT, authorizeAdmin, receiveHeartbeat);

};

export default configureRouter;

// src/routes/authRoutes.ts
/**
 * üö® CORE-BACKEND: Nuclear Authentication Routes
 * 
 * Secure authentication endpoints with comprehensive security controls
 * Compatible with Oracle PL/SQL, JavaScript, Python clients
 * 
 * Classification: CONFIDENTIAL (authentication routes)
 * Retention: 7 years (security requirement)
 * Review Date: Every 3 months (critical security component)
 */

import express from 'express';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { login, validateToken, refreshToken } from '../controllers/authController';
import logger from '../utils/logger';

const router = express.Router();

/**
 * Enhanced rate limiting for authentication endpoints
 * Implements progressive rate limiting based on endpoint sensitivity
 */

// Strict rate limiting for login (prevent brute force)
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Only 5 login attempts per 15 minutes per IP
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many login attempts',
    retry_after: '15 minutes',
    security_note: 'Account protection active'
  },
  handler: (req: Request, res: Response) => {
    const correlationId = (req as any).correlationId || 'unknown';
    
    logger.warn('üö´ Login rate limit exceeded', {
      classification: 'HIGH',
      audit_event: 'LOGIN_RATE_LIMIT_EXCEEDED',
      ip_address: req.ip,
      user_agent: req.headers['user-agent'],
      correlation_id: correlationId,
      security_violation: 'BRUTE_FORCE_PROTECTION'
    });
    
    res.status(429).json({
      error: 'Too many login attempts',
      retry_after: '15 minutes',
      correlation_id: correlationId
    });
  },
  skip: (req: Request) => {
    // Skip rate limiting for health checks or internal requests
    const userAgent = req.headers['user-agent'] || '';
    return userAgent.includes('health-check') || userAgent.includes('monitoring');
  }
});

// Moderate rate limiting for token validation
const validateLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60, // 60 validation attempts per minute per IP
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many validation requests',
    retry_after: '1 minute'
  }
});

// Moderate rate limiting for token refresh
const refreshLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 10, // 10 refresh attempts per 5 minutes per IP
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many refresh requests',
    retry_after: '5 minutes'
  }
});

/**
 * Input validation middleware for authentication endpoints
 * Implements comprehensive input sanitization and validation
 */

// Login input validation
const validateLoginInput = [
  body('username')
    .isString()
    .isLength({ min: 3, max: 50 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Username must be 3-50 characters, alphanumeric with underscore/dash only')
    .trim()
    .escape(),
  
  body('password')
    .isString()
    .isLength({ min: 8, max: 128 })
    .withMessage('Password must be 8-128 characters')
    // Note: We don't escape password as it needs to be compared as-is
];

/**
 * Validation result handler
 * Processes validation errors with security logging
 */
function handleValidationErrors(req: Request, res: Response, next: NextFunction): void {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const correlationId = (req as any).correlationId || 'unknown';
    
    logger.warn('üö´ Input validation failed', {
      classification: 'HIGH',
      audit_event: 'INPUT_VALIDATION_FAILED',
      errors: errors.array(),
      endpoint: req.path,
      client_ip: req.ip,
      correlation_id: correlationId
    });
    
    res.status(400).json({
      error: 'Invalid input',
      details: errors.array().map(err => ({
        field: err.type === 'field' ? err.path : 'unknown',
        message: err.msg
      })),
      correlation_id: correlationId
    });
    return;
  }
  
  next();
}

/**
 * Security headers middleware for authentication endpoints
 * Adds extra security headers for auth-specific protection
 */
function addAuthSecurityHeaders(req: Request, res: Response, next: NextFunction): void {
  // Prevent caching of authentication responses
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  
  // Add authentication-specific security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  // Indicate this is an authentication endpoint
  res.setHeader('X-Auth-Endpoint', 'true');
  
  next();
}

/**
 * Request logging middleware for authentication endpoints
 * Provides enhanced logging for security-sensitive operations
 */
function logAuthRequest(endpoint: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    const correlationId = (req as any).correlationId || 'unknown';
    
    logger.info(`üîê Auth request: ${endpoint}`, {
      classification: 'HIGH',
      audit_event: 'AUTH_REQUEST_RECEIVED',
      endpoint,
      method: req.method,
      client_ip: req.ip,
      user_agent: req.headers['user-agent'],
      content_length: req.headers['content-length'],
      correlation_id: correlationId
    });
    
    next();
  };
}

/**
 * ROUTES DEFINITION
 * All authentication endpoints with comprehensive security
 */

// POST /auth/login - User authentication
router.post('/login',
  addAuthSecurityHeaders,
  logAuthRequest('login'),
  loginLimiter,
  validateLoginInput,
  handleValidationErrors,
  login
);

// POST /auth/validate - Token validation
router.post('/validate',
  addAuthSecurityHeaders,
  logAuthRequest('validate'),
  validateLimiter,
  validateToken
);

// POST /auth/refresh - Token refresh
router.post('/refresh',
  addAuthSecurityHeaders,
  logAuthRequest('refresh'),
  refreshLimiter,
  refreshToken
);

// GET /auth/health - Authentication service health check
router.get('/health', (req: Request, res: Response) => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  const healthStatus = {
    status: 'healthy',
    service: 'authentication',
    timestamp: new Date().toISOString(),
    endpoints: {
      login: 'available',
      validate: 'available',
      refresh: 'available'
    },
    rate_limits: {
      login: '5 requests per 15 minutes',
      validate: '60 requests per minute',
      refresh: '10 requests per 5 minutes'
    },
    security: {
      input_validation: 'active',
      rate_limiting: 'active',
      audit_logging: 'active'
    },
    correlation_id: correlationId
  };
  
  logger.info('üè• Auth health check', {
    classification: 'INTERNAL',
    audit_event: 'AUTH_HEALTH_CHECK',
    correlation_id: correlationId
  });
  
  res.status(200).json(healthStatus);
});

// OPTIONS support for CORS preflight
router.options('*', (req: Request, res: Response) => {
  res.status(200).end();
});

// 404 handler for auth routes
router.use('*', (req: Request, res: Response) => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  logger.warn('üö´ Auth endpoint not found', {
    classification: 'INTERNAL',
    audit_event: 'AUTH_ENDPOINT_NOT_FOUND',
    method: req.method,
    path: req.path,
    client_ip: req.ip,
    correlation_id: correlationId
  });
  
  res.status(404).json({
    error: 'Authentication endpoint not found',
    available_endpoints: [
      'POST /auth/login',
      'POST /auth/validate', 
      'POST /auth/refresh',
      'GET /auth/health'
    ],
    correlation_id: correlationId
  });
});

export default router;
// src/routes/logRoutes.ts
/**
 * üö® CORE-BACKEND: Nuclear Log Ingestion Routes
 * 
 * Multi-tenant log processing endpoints with comprehensive compliance
 * Single responsibility: Log ingestion ONLY
 * 
 * Classification: CONFIDENTIAL (log processing routes)
 * Retention: 7 years (operational requirement)
 * Review Date: Every 3 months (critical component)
 */

import express from 'express';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { emitLog, logHealthCheck } from '../controllers/logController';
import { authenticateJWT } from '../middlewares/authenticateJWT';
import logger from '../utils/logger';
import nuclearAuditLogger from '../middlewares/auditLogger';

const router = express.Router();

/**
 * Rate limiting for log ingestion endpoints
 * Balanced between throughput and abuse prevention
 */

// High-volume rate limiting for log ingestion
const logIngestionLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 1000, // 1000 log entries per minute per IP (high volume)
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Log ingestion rate limit exceeded',
    retry_after: '1 minute',
    note: 'High volume log ingestion detected'
  },
  handler: (req: Request, res: Response) => {
    const correlationId = (req as any).correlationId || 'unknown';
    const tenantName = req.body?.tenant_name || 'unknown';
    
    logger.warn('üö´ Log ingestion rate limit exceeded', {
      classification: 'HIGH',
      audit_event: 'LOG_INGESTION_RATE_LIMIT_EXCEEDED',
      tenant_name: tenantName,
      ip_address: req.ip,
      user_agent: req.headers['user-agent'],
      correlation_id: correlationId,
      security_violation: 'HIGH_VOLUME_ABUSE_PROTECTION'
    });
    
    nuclearAuditLogger.logEvent(
      'RATE_LIMIT_EXCEEDED' as any,
      'Log ingestion rate limit exceeded',
      'FAILURE',
      {
        resource_type: 'log_ingestion_endpoint',
        tenant_name: tenantName,
        source_ip: req.ip,
        correlation_id: correlationId,
        metadata: {
          endpoint: '/emit-log',
          limit_type: 'high_volume_protection',
          window_minutes: 1,
          max_requests: 1000
        }
      }
    );
    
    res.status(429).json({
      error: 'Log ingestion rate limit exceeded',
      retry_after: '1 minute',
      correlation_id: correlationId
    });
  }
});

// Moderate rate limiting for health checks
const healthCheckLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60, // 60 health checks per minute
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many health check requests',
    retry_after: '1 minute'
  }
});

/**
 * Input validation for log ingestion
 * Comprehensive validation with security controls
 */
const validateLogPayload = [
  // Tenant identification
  body('tenant_name')
    .isString()
    .isLength({ min: 1, max: 64 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Tenant name must be 1-64 characters, alphanumeric with underscore/dash only')
    .trim(),
  
  // Service identification
  body('service')
    .isString()
    .isLength({ min: 1, max: 64 })
    .matches(/^[a-zA-Z0-9_-]+$/)
    .withMessage('Service name must be 1-64 characters, alphanumeric with underscore/dash only')
    .trim(),
  
  // Log level
  body('level')
    .isIn(['debug', 'info', 'warn', 'error', 'critical'])
    .withMessage('Level must be one of: debug, info, warn, error, critical'),
  
  // Log message
  body('message')
    .isString()
    .isLength({ min: 1, max: 8192 })
    .withMessage('Message must be 1-8192 characters')
    .trim(),
  
  // Classification (mandatory for compliance)
  body('classification')
    .isIn(['public', 'internal', 'confidential', 'restricted'])
    .withMessage('Classification must be one of: public, internal, confidential, restricted'),
  
  // Retention period
  body('retention_period')
    .optional()
    .isInt({ min: 1, max: 3650 })
    .withMessage('Retention period must be 1-3650 days')
    .toInt(),
  
  // Timestamp (optional)
  body('timestamp')
    .optional()
    .isISO8601()
    .withMessage('Timestamp must be valid ISO 8601 format'),
  
  // Trace ID (optional)
  body('trace_id')
    .optional()
    .isUUID()
    .withMessage('Trace ID must be valid UUID format'),
  
  // Tags (optional)
  body('tags')
    .optional()
    .isArray({ max: 20 })
    .withMessage('Tags must be array with max 20 elements'),
  
  body('tags.*')
    .optional()
    .isString()
    .isLength({ max: 50 })
    .withMessage('Each tag must be string with max 50 characters')
    .trim(),
  
  // Context (optional)
  body('context')
    .optional()
    .isObject()
    .withMessage('Context must be object')
    .custom((value) => {
      try {
        const serialized = JSON.stringify(value);
        if (serialized.length > 32768) { // 32KB limit
          throw new Error('Context too large (max 32KB when serialized)');
        }
        return true;
      } catch (error) {
        throw new Error('Context must be valid JSON object');
      }
    })
];

/**
 * Validation result handler with security logging
 */
function handleLogValidationErrors(req: Request, res: Response, next: NextFunction): void {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const correlationId = (req as any).correlationId || 'unknown';
    const tenantName = req.body?.tenant_name || 'unknown';
    
    logger.warn('üö´ Log payload validation failed', {
      classification: 'HIGH',
      audit_event: 'LOG_PAYLOAD_VALIDATION_FAILED',
      tenant_name: tenantName,
      errors: errors.array(),
      endpoint: req.path,
      client_ip: req.ip,
      correlation_id: correlationId
    });
    
    nuclearAuditLogger.logEvent(
      'DATA_VALIDATION_FAILED' as any,
      'Log payload validation failed',
      'FAILURE',
      {
        resource_type: 'log_payload',
        tenant_name: tenantName,
        source_ip: req.ip,
        correlation_id: correlationId,
        metadata: {
          validation_errors: errors.array(),
          endpoint: req.path,
          security_impact: 'MALFORMED_DATA_ATTEMPT'
        }
      }
    );
    
    res.status(400).json({
      error: 'Invalid log payload',
      details: errors.array().map(err => ({
        field: err.type === 'field' ? err.path : 'unknown',
        message: err.msg
      })),
      correlation_id: correlationId
    });
    return;
  }
  
  next();
}

/**
 * Security headers for log ingestion endpoints
 */
function addLogSecurityHeaders(req: Request, res: Response, next: NextFunction): void {
  // Cache control for log responses
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  
  // Security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  
  // Indicate this is a log processing endpoint
  res.setHeader('X-Log-Endpoint', 'true');
  res.setHeader('X-Service-Type', 'log-ingestion');
  
  next();
}

/**
 * Request logging for log ingestion endpoints
 */
function logIngestionRequest(endpoint: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    const correlationId = (req as any).correlationId || 'unknown';
    const tenantName = req.body?.tenant_name || 'unknown';
    
    logger.info(`üì• Log ingestion request: ${endpoint}`, {
      classification: 'INTERNAL',
      audit_event: 'LOG_INGESTION_REQUEST_RECEIVED',
      endpoint,
      method: req.method,
      tenant_name: tenantName,
      client_ip: req.ip,
      user_agent: req.headers['user-agent'],
      content_length: req.headers['content-length'],
      correlation_id: correlationId
    });
    
    next();
  };
}

/**
 * Authentication verification for log endpoints
 * Ensures only authenticated services can ingest logs
 */
function verifyLogIngestionAuth(req: Request, res: Response, next: NextFunction): void {
  const user = (req as any).user;
  const correlationId = (req as any).correlationId || 'unknown';
  
  if (!user) {
    logger.error('üí• No user context in authenticated request', {
      classification: 'CRITICAL',
      audit_event: 'LOG_INGESTION_AUTH_CONTEXT_MISSING',
      correlation_id: correlationId
    });
    
    res.status(500).json({
      error: 'Authentication context missing',
      correlation_id: correlationId
    });
    return;
  }
  
  // Log successful authentication for audit
  nuclearAuditLogger.logEvent(
    'ACCESS_GRANTED' as any,
    'Log ingestion access granted',
    'SUCCESS',
    {
      resource_type: 'log_ingestion_endpoint',
      user_id: user.username,
      source_ip: req.ip,
      correlation_id: correlationId,
      metadata: {
        user_role: user.role,
        tenant_id: user.tenant_id,
        endpoint: req.originalUrl,
        authentication_method: 'jwt'
      }
    }
  );
  
  next();
}

/**
 * ROUTES DEFINITION
 * Log ingestion endpoints with comprehensive security
 */

// POST /api/emit-log - Main log ingestion endpoint
router.post('/emit-log',
  addLogSecurityHeaders,
  logIngestionRequest('emit-log'),
  logIngestionLimiter,
  authenticateJWT,
  verifyLogIngestionAuth,
  validateLogPayload,
  handleLogValidationErrors,
  emitLog
);

// GET /api/logs/health - Log service health check
router.get('/logs/health',
  addLogSecurityHeaders,
  logIngestionRequest('logs-health'),
  healthCheckLimiter,
  logHealthCheck
);

// GET /api/health - General API health (alias)
router.get('/health', (req: Request, res: Response) => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  const healthStatus = {
    status: 'healthy',
    service: 'log-ingestion-api',
    timestamp: new Date().toISOString(),
    endpoints: {
      emit_log: 'available',
      logs_health: 'available'
    },
    rate_limits: {
      log_ingestion: '1000 requests per minute',
      health_checks: '60 requests per minute'
    },
    security: {
      authentication: 'required',
      input_validation: 'active',
      rate_limiting: 'active',
      audit_logging: 'active'
    },
    compliance: {
      iso27001: 'active',
      gdpr: 'compliant',
      classification_enforcement: 'active'
    },
    correlation_id: correlationId
  };
  
  logger.info('üè• API health check', {
    classification: 'INTERNAL',
    audit_event: 'API_HEALTH_CHECK',
    correlation_id: correlationId
  });
  
  res.status(200).json(healthStatus);
});

// OPTIONS support for CORS preflight
router.options('*', (req: Request, res: Response) => {
  res.status(200).end();
});

// 404 handler for log routes
router.use('*', (req: Request, res: Response) => {
  const correlationId = (req as any).correlationId || 'unknown';
  
  logger.warn('üö´ Log API endpoint not found', {
    classification: 'INTERNAL',
    audit_event: 'LOG_API_ENDPOINT_NOT_FOUND',
    method: req.method,
    path: req.path,
    client_ip: req.ip,
    correlation_id: correlationId
  });
  
  res.status(404).json({
    error: 'Log API endpoint not found',
    available_endpoints: [
      'POST /api/emit-log',
      'GET /api/logs/health',
      'GET /api/health'
    ],
    correlation_id: correlationId
  });
});

export default router;
// src/services/heartbeatEmitter.ts
import axios from "axios";
import config from "../config/envConfig";
import os from "os";
import { getAuthToken } from "../utils/getToken";

let first = true;

export const startHeartbeat = () => {
  setInterval(async () => {
    try {
      const uptime = Math.floor(process.uptime());
      const memoryRssMb = Math.round(process.memoryUsage().rss / 1024 / 1024);
      const heapUsedMb = Math.round(
        process.memoryUsage().heapUsed / 1024 / 1024
      );
      const cpuUsage = process.cpuUsage();
      const cpuUserMs = Math.round(cpuUsage.user / 1000);
      const cpuSystemMs = Math.round(cpuUsage.system / 1000);
      const hostname = os.hostname();
      const loadAvg = os.loadavg();
      const cpuLoad1m =
        loadAvg[0] > 0 ? parseFloat(loadAvg[0].toFixed(2)) : undefined;

      const metadata: Record<string, any> = {
        uptime_sec: uptime,
        memory_rss_mb: memoryRssMb,
        heap_used_mb: heapUsedMb,
        cpu_user_ms: cpuUserMs,
        cpu_system_ms: cpuSystemMs,
        hostname,
      };

      if (cpuLoad1m !== undefined) {
        metadata.cpu_load_1m = cpuLoad1m;
      }

      const payload = {
        client_id: config.tenantId,
        service: config.serviceName || "core_services",
        timestamp: new Date().toISOString(),
        status: first ? "STARTUP" : "OK",
        metadata,
      };

      if (first) {
        payload.status = "STARTUP";
        first = false;
      }

      const token = await getAuthToken();
      await axios.post(`${config.apiUrl}/heartbeat`, payload, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      console.log("‚úÖ Heartbeat sent:", payload.status);
    } catch (err: any) {
      if (axios.isAxiosError(err)) {
        console.error("‚ùå Axios error:", err.response?.data || err.message);
      } else {
        console.error("‚ùå Unknown error:", err);
      }
    }
  }, 60000); //every 60 seconds
  console.log("Heartbeat emitter started, sending every 1 minute");
};

// src/services/retentionService.ts
/**
 * üö® CORE-BACKEND: Nuclear Data Retention Service
 * 
 * Automated GDPR-compliant data retention and deletion
 * Implements Article 17 (Right to Erasure) with comprehensive audit trail
 * 
 * Classification: CONFIDENTIAL (data processing service)
 * Retention: 10 years (regulatory requirement)
 * Review Date: Every 3 months (critical compliance component)
 */

import cron from 'node-cron';
import db from '../config/db';
import logger from '../utils/logger';
import nuclearAuditLogger from '../middlewares/auditLogger';

/**
 * Retention policy interface
 */
interface RetentionPolicy {
  table_name: string;
  retention_column: string;
  classification_column?: string;
  description: string;
  default_retention_days: number;
  classification_overrides?: Record<string, number>;
}

/**
 * Deletion result interface
 */
interface DeletionResult {
  table_name: string;
  records_deleted: number;
  oldest_record_deleted?: string;
  newest_record_deleted?: string;
  deletion_duration_ms: number;
  errors: string[];
}

/**
 * Retention service statistics
 */
interface RetentionStats {
  total_tables_processed: number;
  total_records_deleted: number;
  total_duration_ms: number;
  successful_deletions: number;
  failed_deletions: number;
  tables_with_errors: string[];
}

/**
 * Nuclear retention policies
 * Defines retention rules for all data tables
 */
const RETENTION_POLICIES: RetentionPolicy[] = [
  {
    table_name: 'logs',
    retention_column: 'retention_until',
    classification_column: 'classification',
    description: 'Application logs with classification-based retention',
    default_retention_days: 365, // 1 year default
    classification_overrides: {
      'public': 30,        // 30 days
      'internal': 365,     // 1 year  
      'confidential': 2555, // 7 years
      'restricted': 3650   // 10 years
    }
  },
  {
    table_name: 'audit_logs',
    retention_column: 'retention_until',
    description: 'Audit logs with regulatory retention requirements',
    default_retention_days: 2555 // 7 years for audit trails
  },
  {
    table_name: 'error_logs',
    retention_column: 'retention_until',
    description: 'Error logs for troubleshooting and security analysis',
    default_retention_days: 1095 // 3 years
  },
  {
    table_name: 'security_events',
    retention_column: 'retention_until',
    description: 'Security events for incident investigation',
    default_retention_days: 3650 // 10 years for security events
  }
];

/**
 * Service state tracking
 */
interface ServiceState {
  isRunning: boolean;
  lastRunTime: Date | null;
  nextRunTime: Date | null;
  totalRunsCompleted: number;
  totalRecordsDeleted: number;
  cronJob: cron.ScheduledTask | null;
}

let serviceState: ServiceState = {
  isRunning: false,
  lastRunTime: null,
  nextRunTime: null,
  totalRunsCompleted: 0,
  totalRecordsDeleted: 0,
  cronJob: null
};

/**
 * Validate retention policy configuration
 */
function validateRetentionPolicies(): void {
  logger.info('üîç Validating retention policies...', {
    classification: 'INTERNAL',
    audit_event: 'RETENTION_POLICY_VALIDATION_STARTED',
    policy_count: RETENTION_POLICIES.length
  });
  
  const errors: string[] = [];
  
  RETENTION_POLICIES.forEach((policy, index) => {
    // Check required fields
    if (!policy.table_name) {
      errors.push(`Policy ${index}: Missing table_name`);
    }
    
    if (!policy.retention_column) {
      errors.push(`Policy ${index}: Missing retention_column`);
    }
    
    if (!policy.description) {
      errors.push(`Policy ${index}: Missing description`);
    }
    
    if (!policy.default_retention_days || policy.default_retention_days <= 0) {
      errors.push(`Policy ${index}: Invalid default_retention_days`);
    }
    
    // Validate classification overrides
    if (policy.classification_overrides) {
      Object.entries(policy.classification_overrides).forEach(([classification, days]) => {
        if (days <= 0) {
          errors.push(`Policy ${index}: Invalid retention days for classification ${classification}`);
        }
      });
    }
  });
  
  if (errors.length > 0) {
    logger.error('üí• Retention policy validation failed', {
      classification: 'CRITICAL',
      audit_event: 'RETENTION_POLICY_VALIDATION_FAILED',
      errors
    });
    
    throw new Error(`Retention policy validation failed: ${errors.join(', ')}`);
  }
  
  logger.info('‚úÖ Retention policies validated successfully', {
    classification: 'INTERNAL',
    audit_event: 'RETENTION_POLICY_VALIDATION_SUCCESS',
    validated_policies: RETENTION_POLICIES.length
  });
}

/**
 * Check if table exists in database
 */
async function tableExists(tableName: string): Promise<boolean> {
  try {
    const result = await db.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `, [tableName]);
    
    return result.rows[0].exists;
  } catch (error) {
    logger.warn(`‚ö†Ô∏è Error checking table existence: ${tableName}`, {
      classification: 'HIGH',
      audit_event: 'TABLE_EXISTENCE_CHECK_ERROR',
      table_name: tableName,
      error: error instanceof Error ? error.message : String(error)
    });
    
    return false;
  }
}

/**
 * Delete expired records from a table
 */
async function deleteExpiredRecords(policy: RetentionPolicy): Promise<DeletionResult> {
  const startTime = Date.now();
  const result: DeletionResult = {
    table_name: policy.table_name,
    records_deleted: 0,
    deletion_duration_ms: 0,
    errors: []
  };
  
  try {
    logger.info(`üßπ Starting deletion for table: ${policy.table_name}`, {
      classification: 'HIGH',
      audit_event: 'RETENTION_DELETION_STARTED',
      table_name: policy.table_name,
      policy_description: policy.description
    });
    
    // Check if table exists
    const exists = await tableExists(policy.table_name);
    if (!exists) {
      const error = `Table ${policy.table_name} does not exist`;
      result.errors.push(error);
      
      logger.warn(`‚ö†Ô∏è Table not found: ${policy.table_name}`, {
        classification: 'HIGH',
        audit_event: 'RETENTION_TABLE_NOT_FOUND',
        table_name: policy.table_name
      });
      
      return result;
    }
    
    // Build deletion query
    const deleteQuery = `
      DELETE FROM ${policy.table_name}
      WHERE ${policy.retention_column} <= NOW()
      RETURNING 
        COUNT(*) as deleted_count,
        MIN(created_at) as oldest_deleted,
        MAX(created_at) as newest_deleted
    `;
    
    // Execute deletion within transaction
    await db.withTransaction(async (client) => {
      // First, get count of records to be deleted for audit
      const countQuery = `
        SELECT COUNT(*) as expired_count
        FROM ${policy.table_name}
        WHERE ${policy.retention_column} <= NOW()
      `;
      
      const countResult = await client.query(countQuery);
      const expiredCount = parseInt(countResult.rows[0].expired_count);
      
      if (expiredCount === 0) {
        logger.info(`‚ÑπÔ∏è No expired records found in ${policy.table_name}`, {
          classification: 'INTERNAL',
          audit_event: 'RETENTION_NO_EXPIRED_RECORDS',
          table_name: policy.table_name
        });
        return;
      }
      
      // Log before deletion for audit trail
      logger.info(`üóëÔ∏è Deleting ${expiredCount} expired records from ${policy.table_name}`, {
        classification: 'HIGH',
        audit_event: 'RETENTION_DELETION_EXECUTING',
        table_name: policy.table_name,
        records_to_delete: expiredCount
      });
      
      // Execute deletion
      const deleteResult = await client.query(`
        DELETE FROM ${policy.table_name}
        WHERE ${policy.retention_column} <= NOW()
      `);
      
      result.records_deleted = deleteResult.rowCount || 0;
      
      // Log successful deletion
      nuclearAuditLogger.logEvent(
        'DATA_RETENTION_CLEANUP' as any,
        `Automated retention cleanup for ${policy.table_name}`,
        'SUCCESS',
        {
          resource_type: 'database_table',
          resource_id: policy.table_name,
          metadata: {
            table_name: policy.table_name,
            records_deleted: result.records_deleted,
            policy_description: policy.description,
            legal_basis: 'gdpr_article_17',
            data_categories: ['log_data', 'application_data']
          }
        }
      );
      
    });
    
    result.deletion_duration_ms = Date.now() - startTime;
    
    logger.info(`‚úÖ Deletion completed for ${policy.table_name}`, {
      classification: 'HIGH',
      audit_event: 'RETENTION_DELETION_COMPLETED',
      table_name: policy.table_name,
      records_deleted: result.records_deleted,
      duration_ms: result.deletion_duration_ms
    });
    
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    result.errors.push(errorMessage);
    result.deletion_duration_ms = Date.now() - startTime;
    
    logger.error(`üí• Deletion failed for ${policy.table_name}`, {
      classification: 'CRITICAL',
      audit_event: 'RETENTION_DELETION_FAILED',
      table_name: policy.table_name,
      error: errorMessage,
      duration_ms: result.deletion_duration_ms
    });
    
    // Log failed deletion for audit
    nuclearAuditLogger.logEvent(
      'DATA_RETENTION_CLEANUP' as any,
      `Failed retention cleanup for ${policy.table_name}`,
      'FAILURE',
      {
        resource_type: 'database_table',
        resource_id: policy.table_name,
        metadata: {
          table_name: policy.table_name,
          error_message: errorMessage,
          policy_description: policy.description
        }
      }
    );
  }
  
  return result;
}

/**
 * Execute retention cleanup for all policies
 */
async function executeRetentionCleanup(): Promise<RetentionStats> {
  const startTime = Date.now();
  
  logger.info('üöÄ Starting scheduled retention cleanup', {
    classification: 'HIGH',
    audit_event: 'RETENTION_CLEANUP_STARTED',
    policies_to_process: RETENTION_POLICIES.length,
    scheduled_time: new Date().toISOString()
  });
  
  const stats: RetentionStats = {
    total_tables_processed: 0,
    total_records_deleted: 0,
    total_duration_ms: 0,
    successful_deletions: 0,
    failed_deletions: 0,
    tables_with_errors: []
  };
  
  // Process each retention policy
  for (const policy of RETENTION_POLICIES) {
    stats.total_tables_processed++;
    
    try {
      const result = await deleteExpiredRecords(policy);
      
      stats.total_records_deleted += result.records_deleted;
      
      if (result.errors.length > 0) {
        stats.failed_deletions++;
        stats.tables_with_errors.push(policy.table_name);
      } else {
        stats.successful_deletions++;
      }
      
    } catch (error) {
      stats.failed_deletions++;
      stats.tables_with_errors.push(policy.table_name);
      
      logger.error(`üí• Policy execution failed for ${policy.table_name}`, {
        classification: 'CRITICAL',
        audit_event: 'RETENTION_POLICY_EXECUTION_FAILED',
        table_name: policy.table_name,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  
  stats.total_duration_ms = Date.now() - startTime;
  
  // Update service state
  serviceState.lastRunTime = new Date();
  serviceState.totalRunsCompleted++;
  serviceState.totalRecordsDeleted += stats.total_records_deleted;
  
  // Log completion statistics
  logger.info('üìä Retention cleanup completed', {
    classification: 'HIGH',
    audit_event: 'RETENTION_CLEANUP_COMPLETED',
    ...stats,
    next_run_time: serviceState.nextRunTime?.toISOString()
  });
  
  // Log compliance event
  nuclearAuditLogger.logEvent(
    'DATA_RETENTION_CLEANUP' as any,
    'Scheduled data retention cleanup completed',
    stats.failed_deletions > 0 ? 'PARTIAL' : 'SUCCESS',
    {
      metadata: {
        total_records_deleted: stats.total_records_deleted,
        tables_processed: stats.total_tables_processed,
        successful_deletions: stats.successful_deletions,
        failed_deletions: stats.failed_deletions,
        duration_ms: stats.total_duration_ms,
        compliance_framework: 'GDPR_Article_17',
        legal_basis: 'automated_retention_policy'
      }
    }
  );
  
  return stats;
}

/**
 * Calculate next run time
 */
function calculateNextRunTime(cronExpression: string): Date | null {
  try {
    // Use cron.validate to check if expression is valid
    const isValid = cron.validate(cronExpression);
    if (!isValid) {
      throw new Error('Invalid cron expression');
    }
    
    // For next run time, we'll calculate it manually or return null
    // node-cron doesn't expose nextDates method reliably
    logger.info(`‚ÑπÔ∏è Next run scheduled with cron: ${cronExpression}`, {
      classification: 'INTERNAL',
      audit_event: 'RETENTION_SCHEDULE_CALCULATED',
      cron_expression: cronExpression
    });
    
    return null; // Will be updated when job actually runs
  } catch (error) {
    logger.error('üí• Error validating cron expression', {
      classification: 'HIGH',
      audit_event: 'RETENTION_SCHEDULE_CALCULATION_ERROR',
      cron_expression: cronExpression,
      error: error instanceof Error ? error.message : String(error)
    });
    return null;
  }
}

/**
 * Start the retention service
 */
export function startRetentionService(cronExpression: string = '0 2 * * *'): void {
  try {
    // Validate retention policies first
    validateRetentionPolicies();
    
    // Check if already running
    if (serviceState.isRunning) {
      logger.warn('‚ö†Ô∏è Retention service already running', {
        classification: 'INTERNAL',
        audit_event: 'RETENTION_SERVICE_ALREADY_RUNNING'
      });
      return;
    }
    
    // Calculate next run time (simplified)
    serviceState.nextRunTime = calculateNextRunTime(cronExpression);
    
    // Create and start cron job
    serviceState.cronJob = cron.schedule(cronExpression, async () => {
      try {
        // Update next run time when job executes
        serviceState.nextRunTime = new Date(Date.now() + 24 * 60 * 60 * 1000); // Approximate next day for daily jobs
        await executeRetentionCleanup();
      } catch (error) {
        logger.error('üí• CRITICAL: Retention cleanup execution failed', {
          classification: 'CRITICAL',
          audit_event: 'RETENTION_CLEANUP_EXECUTION_ERROR',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }, {
      scheduled: true,
      timezone: 'UTC' // Always use UTC for consistency
    });
    
    serviceState.isRunning = true;
    
    logger.info('üöÄ Nuclear retention service started successfully', {
      classification: 'HIGH',
      audit_event: 'RETENTION_SERVICE_STARTED',
      cron_expression: cronExpression,
      next_run_time: serviceState.nextRunTime?.toISOString(),
      policies_configured: RETENTION_POLICIES.length,
      timezone: 'UTC'
    });
    
    // Log compliance initialization
    nuclearAuditLogger.logEvent(
      'SERVICE_STARTED' as any,
      'GDPR retention service initialized',
      'SUCCESS',
      {
        resource_type: 'retention_service',
        resource_id: 'data_retention_service',
        metadata: {
          service_name: 'data_retention_service',
          compliance_framework: 'GDPR_Article_17',
          retention_policies: RETENTION_POLICIES.length,
          schedule: cronExpression
        }
      }
    );
    
  } catch (error) {
    logger.error('üí• CRITICAL: Failed to start retention service', {
      classification: 'CRITICAL',
      audit_event: 'RETENTION_SERVICE_START_FAILED',
      error: error instanceof Error ? error.message : String(error)
    });
    
    throw error;
  }
}

/**
 * Stop the retention service
 */
export function stopRetentionService(): void {
  if (!serviceState.isRunning || !serviceState.cronJob) {
    logger.warn('‚ö†Ô∏è Retention service not running', {
      classification: 'INTERNAL',
      audit_event: 'RETENTION_SERVICE_NOT_RUNNING'
    });
    return;
  }
  
  serviceState.cronJob.stop();
  // Note: node-cron ScheduledTask doesn't have destroy() method
  serviceState.cronJob = null;
  serviceState.isRunning = false;
  serviceState.nextRunTime = null;
  
  logger.info('üõë Retention service stopped', {
    classification: 'HIGH',
    audit_event: 'RETENTION_SERVICE_STOPPED',
    total_runs_completed: serviceState.totalRunsCompleted,
    total_records_deleted: serviceState.totalRecordsDeleted
  });
}

/**
 * Get service status
 */
export function getRetentionServiceStatus(): {
  isRunning: boolean;
  lastRunTime: Date | null;
  nextRunTime: Date | null;
  totalRunsCompleted: number;
  totalRecordsDeleted: number;
  policies: RetentionPolicy[];
} {
  return {
    isRunning: serviceState.isRunning,
    lastRunTime: serviceState.lastRunTime,
    nextRunTime: serviceState.nextRunTime,
    totalRunsCompleted: serviceState.totalRunsCompleted,
    totalRecordsDeleted: serviceState.totalRecordsDeleted,
    policies: [...RETENTION_POLICIES]
  };
}

/**
 * Manual retention cleanup (for testing or emergency)
 */
export async function manualRetentionCleanup(): Promise<RetentionStats> {
  logger.info('üîß Manual retention cleanup initiated', {
    classification: 'HIGH',
    audit_event: 'MANUAL_RETENTION_CLEANUP_STARTED'
  });
  
  const stats = await executeRetentionCleanup();
  
  logger.info('‚úÖ Manual retention cleanup completed', {
    classification: 'HIGH',
    audit_event: 'MANUAL_RETENTION_CLEANUP_COMPLETED',
    ...stats
  });
  
  return stats;
}

export default {
  startRetentionService,
  stopRetentionService,
  getRetentionServiceStatus,
  manualRetentionCleanup
};
// src/utils/getToken.ts
import axios from "axios";
import config from "../config/envConfig";

let cachedToken = "";
let tokenExpiresAt = 0;

export async function getAuthToken(): Promise<string> {
  const now = Date.now();
  if (cachedToken && now < tokenExpiresAt) {
    return cachedToken;
  }

  try {
    
    if (!config.authUrl || !config.authUsername || !config.authPassword) {
      throw new Error("Missing authentication configuration");
    }

    console.log("üîë Requesting new auth token...");
    console.log("üîë Auth URL:", config.authUrl);
    console.log("üîë Auth Username:", config.authUsername);
    console.log("üîë Auth Password:", config.authPassword);

    const response = await axios.post(`${config.authUrl}`, {
      username: config.authUsername,
      password: config.authPassword,
    });

    if (response.status !== 200 || !response.data?.token) {
      throw new Error("Invalid response from auth server");
    }

    cachedToken = response.data.token;
    const expiresIn = response.data.expiresIn || 3600; // en segundos
    tokenExpiresAt = now + expiresIn * 1000 - 10000; // 10s de margen

    return cachedToken;
  } catch (err: any) {
    console.error("‚ùå Failed to get auth token:", err.response?.data || err.message);
    throw new Error("Authentication failed");
  }
}

// src/utils/gracefulShutdown.ts
/**
 * üö® CORE-BACKEND: Nuclear Graceful Shutdown
 * 
 * Production-ready graceful shutdown for containerized environments
 * Ensures clean termination with audit trail and resource cleanup
 * 
 * Classification: CONFIDENTIAL (system infrastructure)
 * Retention: Service lifetime (operational requirement)
 * Review Date: Every 3 months (critical infrastructure)
 */

import { Server } from 'http';
import logger from './logger';
import db from '../config/db';

/**
 * Shutdown options interface
 */
interface ShutdownOptions {
  timeout?: number;           // Max time to wait for graceful shutdown (ms)
  signals?: string[];         // Signals to handle
  onShutdown?: () => Promise<void>; // Custom cleanup function
  forceExit?: boolean;        // Force exit after timeout
}

/**
 * Shutdown state tracking
 */
interface ShutdownState {
  isShuttingDown: boolean;
  shutdownStartTime: number;
  activeConnections: number;
  shutdownReason: string;
  shutdownInitiator: string;
}

/**
 * Default shutdown configuration
 */
const DEFAULT_OPTIONS: Required<ShutdownOptions> = {
  timeout: 30000,  // 30 seconds
  signals: ['SIGTERM', 'SIGINT', 'SIGUSR2'],
  onShutdown: async () => {},
  forceExit: true
};

/**
 * Global shutdown state
 */
let shutdownState: ShutdownState = {
  isShuttingDown: false,
  shutdownStartTime: 0,
  activeConnections: 0,
  shutdownReason: '',
  shutdownInitiator: ''
};

/**
 * Track active connections for graceful shutdown
 */
function trackConnections(server: Server): void {
  server.on('connection', (socket) => {
    shutdownState.activeConnections++;
    
    socket.on('close', () => {
      shutdownState.activeConnections--;
    });
  });
}

/**
 * Cleanup database connections
 */
async function cleanupDatabase(): Promise<void> {
  try {
    logger.info('üîÑ Closing database connections...', {
      classification: 'INTERNAL',
      audit_event: 'DB_SHUTDOWN_STARTED'
    });
    
    await db.shutdown();
    
    logger.info('‚úÖ Database connections closed successfully', {
      classification: 'INTERNAL',
      audit_event: 'DB_SHUTDOWN_COMPLETED'
    });
  } catch (error) {
    logger.error('üí• Error closing database connections', {
      classification: 'HIGH',
      audit_event: 'DB_SHUTDOWN_ERROR',
      error: error instanceof Error ? error.message : String(error)
    });
    
    throw error;
  }
}

/**
 * Close HTTP server gracefully
 */
async function closeServer(server: Server, timeout: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const shutdownTimer = setTimeout(() => {
      logger.warn('‚ö†Ô∏è Server shutdown timeout reached, forcing close', {
        classification: 'HIGH',
        audit_event: 'SERVER_SHUTDOWN_TIMEOUT',
        timeout_ms: timeout,
        active_connections: shutdownState.activeConnections
      });
      
      // Force close all connections
      server.closeAllConnections?.();
      reject(new Error('Server shutdown timeout'));
    }, timeout);
    
    server.close((error) => {
      clearTimeout(shutdownTimer);
      
      if (error) {
        logger.error('üí• Error closing HTTP server', {
          classification: 'HIGH',
          audit_event: 'SERVER_SHUTDOWN_ERROR',
          error: error.message
        });
        reject(error);
      } else {
        logger.info('‚úÖ HTTP server closed successfully', {
          classification: 'INTERNAL',
          audit_event: 'SERVER_SHUTDOWN_COMPLETED'
        });
        resolve();
      }
    });
    
    // Stop accepting new connections
    logger.info('üîÑ Stopping new connections...', {
      classification: 'INTERNAL',
      audit_event: 'SERVER_STOP_NEW_CONNECTIONS'
    });
  });
}

/**
 * Perform comprehensive cleanup
 */
async function performCleanup(options: Required<ShutdownOptions>): Promise<void> {
  const cleanupStartTime = Date.now();
  
  try {
    logger.info('üßπ Starting application cleanup...', {
      classification: 'INTERNAL',
      audit_event: 'CLEANUP_STARTED',
      shutdown_reason: shutdownState.shutdownReason
    });
    
    // Execute custom cleanup function
    if (options.onShutdown) {
      logger.info('üîÑ Executing custom cleanup...', {
        classification: 'INTERNAL',
        audit_event: 'CUSTOM_CLEANUP_STARTED'
      });
      
      await options.onShutdown();
      
      logger.info('‚úÖ Custom cleanup completed', {
        classification: 'INTERNAL',
        audit_event: 'CUSTOM_CLEANUP_COMPLETED'
      });
    }
    
    // Cleanup database connections
    await cleanupDatabase();
    
    const cleanupDuration = Date.now() - cleanupStartTime;
    
    logger.info('‚úÖ Application cleanup completed successfully', {
      classification: 'INTERNAL',
      audit_event: 'CLEANUP_COMPLETED',
      cleanup_duration_ms: cleanupDuration
    });
    
  } catch (error) {
    const cleanupDuration = Date.now() - cleanupStartTime;
    
    logger.error('üí• Error during application cleanup', {
      classification: 'CRITICAL',
      audit_event: 'CLEANUP_ERROR',
      error: error instanceof Error ? error.message : String(error),
      cleanup_duration_ms: cleanupDuration
    });
    
    throw error;
  }
}

/**
 * Log final shutdown statistics
 */
function logShutdownStats(): void {
  const shutdownDuration = Date.now() - shutdownState.shutdownStartTime;
  
  logger.info('üìä Shutdown statistics', {
    classification: 'INTERNAL',
    audit_event: 'SHUTDOWN_STATISTICS',
    shutdown_reason: shutdownState.shutdownReason,
    shutdown_initiator: shutdownState.shutdownInitiator,
    total_duration_ms: shutdownDuration,
    process_uptime_seconds: Math.floor(process.uptime()),
    process_pid: process.pid,
    memory_usage: process.memoryUsage(),
    final_active_connections: shutdownState.activeConnections
  });
}

/**
 * Execute graceful shutdown sequence
 */
async function executeShutdown(
  server: Server,
  reason: string,
  initiator: string,
  options: Required<ShutdownOptions>
): Promise<void> {
  
  // Prevent multiple shutdown attempts
  if (shutdownState.isShuttingDown) {
    logger.warn('‚ö†Ô∏è Shutdown already in progress, ignoring duplicate signal', {
      classification: 'INTERNAL',
      audit_event: 'DUPLICATE_SHUTDOWN_SIGNAL',
      reason,
      initiator
    });
    return;
  }
  
  // Initialize shutdown state
  shutdownState.isShuttingDown = true;
  shutdownState.shutdownStartTime = Date.now();
  shutdownState.shutdownReason = reason;
  shutdownState.shutdownInitiator = initiator;
  
  logger.info('üîÑ Graceful shutdown initiated', {
    classification: 'HIGH',
    audit_event: 'SHUTDOWN_INITIATED',
    reason,
    initiator,
    process_pid: process.pid,
    active_connections: shutdownState.activeConnections,
    timeout_ms: options.timeout
  });
  
  try {
    // Set up force exit timeout
    const forceExitTimer = setTimeout(() => {
      logger.error('üí• CRITICAL: Graceful shutdown timeout, forcing exit', {
        classification: 'CRITICAL',
        audit_event: 'SHUTDOWN_FORCE_EXIT',
        timeout_ms: options.timeout,
        shutdown_duration_ms: Date.now() - shutdownState.shutdownStartTime
      });
      
      logShutdownStats();
      process.exit(1);
    }, options.timeout);
    
    // Close HTTP server
    await closeServer(server, options.timeout - 5000); // Reserve 5s for cleanup
    
    // Perform application cleanup
    await performCleanup(options);
    
    // Clear force exit timer
    clearTimeout(forceExitTimer);
    
    // Log successful shutdown
    logger.info('‚úÖ Graceful shutdown completed successfully', {
      classification: 'HIGH',
      audit_event: 'SHUTDOWN_COMPLETED',
      shutdown_duration_ms: Date.now() - shutdownState.shutdownStartTime
    });
    
    logShutdownStats();
    
    // Exit gracefully
    if (options.forceExit) {
      process.exit(0);
    }
    
  } catch (error) {
    logger.error('üí• CRITICAL: Graceful shutdown failed', {
      classification: 'CRITICAL',
      audit_event: 'SHUTDOWN_FAILED',
      error: error instanceof Error ? error.message : String(error),
      shutdown_duration_ms: Date.now() - shutdownState.shutdownStartTime
    });
    
    logShutdownStats();
    
    // Force exit on failure
    if (options.forceExit) {
      process.exit(1);
    }
  }
}

/**
 * Setup graceful shutdown handlers
 */
export function gracefulShutdown(
  server: Server,
  userOptions: Partial<ShutdownOptions> = {}
): (reason: string) => void {
  
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  
  // Track server connections
  trackConnections(server);
  
  // Log initialization
  logger.info('üõ°Ô∏è Graceful shutdown handlers initialized', {
    classification: 'INTERNAL',
    audit_event: 'SHUTDOWN_HANDLERS_INITIALIZED',
    signals: options.signals,
    timeout_ms: options.timeout,
    force_exit: options.forceExit
  });
  
  // Create shutdown function
  const shutdown = (reason: string) => {
    executeShutdown(server, reason, 'manual', options);
  };
  
  // Setup signal handlers
  options.signals.forEach(signal => {
    process.on(signal, () => {
      executeShutdown(server, `Signal: ${signal}`, 'system', options);
    });
  });
  
  // Handle uncaught exceptions
  process.on('uncaughtException', (error) => {
    logger.error('üí• CRITICAL: Uncaught exception', {
      classification: 'CRITICAL',
      audit_event: 'UNCAUGHT_EXCEPTION',
      error: error.message,
      stack: error.stack
    });
    
    executeShutdown(server, 'Uncaught Exception', 'system', options);
  });
  
  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('üí• CRITICAL: Unhandled promise rejection', {
      classification: 'CRITICAL',
      audit_event: 'UNHANDLED_REJECTION',
      reason: String(reason),
      promise: String(promise)
    });
    
    executeShutdown(server, 'Unhandled Promise Rejection', 'system', options);
  });
  
  return shutdown;
}

/**
 * Check if shutdown is in progress
 */
export function isShuttingDown(): boolean {
  return shutdownState.isShuttingDown;
}

/**
 * Get current shutdown state
 */
export function getShutdownState(): Readonly<ShutdownState> {
  return { ...shutdownState };
}

export default gracefulShutdown;
// src/utils/logger.ts
/**
 * üö® CORE-BACKEND: Nuclear Structured Logger
 * 
 * Compliance-ready structured logging with comprehensive security
 * Supports ISO 27001, GDPR, and Zero Trust audit requirements
 * 
 * Classification: CONFIDENTIAL (logging infrastructure)
 * Retention: 7 years (audit requirement)
 * Review Date: Every 3 months (critical security component)
 */

import { createLogger, format, transports, Logger } from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import path from 'path';
import fs from 'fs';

/**
 * Log entry interface for structured logging
 * Ensures compliance with audit and security requirements
 */
interface LogEntry {
  // Core log data
  message: string;
  level?: 'debug' | 'info' | 'warn' | 'error';
  
  // Compliance fields (ISO 27001 A.12.4.1)
  classification?: 'PUBLIC' | 'INTERNAL' | 'HIGH' | 'CONFIDENTIAL' | 'CRITICAL';
  audit_event?: string;
  
  // Correlation and tracing
  correlation_id?: string;
  trace_id?: string;
  
  // Security context
  user_id?: string;
  client_ip?: string;
  user_agent?: string;
  
  // Business context
  tenant_name?: string;
  service?: string;
  action?: string;
  
  // Technical context
  duration_ms?: number;
  error_code?: string;
  stack?: string;
  
  // Additional structured data
  [key: string]: any;
}

/**
 * Classification-based log levels
 * Maps ISO 27001 classifications to appropriate log levels
 */
const CLASSIFICATION_LEVELS: Record<string, string> = {
  'PUBLIC': 'info',
  'INTERNAL': 'info', 
  'HIGH': 'warn',
  'CONFIDENTIAL': 'warn',
  'CRITICAL': 'error'
};

/**
 * Sensitive field patterns for data sanitization
 * Prevents logging of sensitive information
 */
const SENSITIVE_PATTERNS = [
  /password/i,
  /secret/i,
  /token/i,
  /key/i,
  /auth/i,
  /credential/i,
  /private/i
];

/**
 * Sanitize log data to prevent sensitive information leakage
 * Implements data protection for compliance
 */
function sanitizeLogData(data: any): any {
  if (typeof data !== 'object' || data === null) {
    return data;
  }
  
  if (Array.isArray(data)) {
    return data.map(sanitizeLogData);
  }
  
  const sanitized: any = {};
  
  for (const [key, value] of Object.entries(data)) {
    // Check if key contains sensitive patterns
    const isSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(key));
    
    if (isSensitive) {
      sanitized[key] = '[REDACTED]';
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeLogData(value);
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}

/**
 * Custom log formatter for structured output
 * Provides both human-readable and machine-parseable formats
 */
const structuredFormat = format.printf((info) => {
  const {
    timestamp,
    level,
    message,
    classification = 'INTERNAL',
    audit_event,
    correlation_id,
    ...meta
  } = info;
  
  // Sanitize metadata
  const sanitizedMeta = sanitizeLogData(meta);
  
  // Build structured log entry
  const logEntry: any = {
    timestamp,
    level: level.toUpperCase(),
    classification,
    message
  };
  
  if (audit_event) {
    logEntry.audit_event = audit_event;
  }
  
  if (correlation_id) {
    logEntry.correlation_id = correlation_id;
  }
  
  if (Object.keys(sanitizedMeta).length > 0) {
    logEntry.metadata = sanitizedMeta;
  }
  
  return JSON.stringify(logEntry);
});

/**
 * Human-readable format for console output
 * Provides colored, readable logs for development
 */
const consoleFormat = format.printf((info) => {
  const {
    timestamp,
    level,
    message,
    classification = 'INTERNAL',
    correlation_id,
    audit_event,
    ...meta
  } = info;
  
  let output = `${timestamp} [${level.toUpperCase()}]`;
  
  if (classification !== 'INTERNAL') {
    output += ` [${classification}]`;
  }
  
  if (correlation_id && typeof correlation_id === 'string') {
    output += ` [${correlation_id.substring(0, 8)}]`;
  }
  
  output += `: ${message}`;
  
  if (audit_event) {
    output += ` (${audit_event})`;
  }
  
  // Add metadata if present (simplified for console)
  const sanitizedMeta = sanitizeLogData(meta);
  if (Object.keys(sanitizedMeta).length > 0) {
    output += ` ${JSON.stringify(sanitizedMeta)}`;
  }
  
  return output;
});

/**
 * Create logs directory if it doesn't exist
 */
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

/**
 * Determine log level from environment with security defaults
 */
const getLogLevel = (): string => {
  const envLevel = process.env.LOG_LEVEL?.toLowerCase();
  const validLevels = ['debug', 'info', 'warn', 'error'];
  
  if (envLevel && validLevels.includes(envLevel)) {
    return envLevel;
  }
  
  // Security-first defaults
  return process.env.NODE_ENV === 'production' ? 'info' : 'debug';
};

/**
 * Nuclear Winston logger configuration
 * Implements comprehensive logging with security and compliance
 */
const nuclearLogger = createLogger({
  level: getLogLevel(),
  
  // Default format for structured logging
  format: format.combine(
    format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss.SSS'
    }),
    format.errors({ stack: true }),
    structuredFormat
  ),
  
  // Transport configuration
  transports: [
    // Console output (development-friendly)
    new transports.Console({
      level: getLogLevel(),
      format: format.combine(
        format.colorize({
          colors: {
            debug: 'blue',
            info: 'green', 
            warn: 'yellow',
            error: 'red'
          }
        }),
        format.timestamp({
          format: 'HH:mm:ss.SSS'
        }),
        consoleFormat
      )
    }),
    
    // Application logs with daily rotation
    new DailyRotateFile({
      filename: path.join(logsDir, 'core-backend-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '100m',      // Max 100MB per file
      maxFiles: '30d',      // Keep 30 days
      level: 'info',
      format: structuredFormat
    }),
    
    // Error logs (separate file for critical issues)
    new DailyRotateFile({
      filename: path.join(logsDir, 'core-backend-error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '50m',       // Max 50MB per file
      maxFiles: '90d',      // Keep 90 days for errors
      level: 'error',
      format: structuredFormat
    }),
    
    // Audit logs (compliance-specific)
    new DailyRotateFile({
      filename: path.join(logsDir, 'core-backend-audit-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '200m',      // Larger for audit trails
      maxFiles: '2555d',    // 7 years retention (ISO 27001)
      level: 'info',
      format: format.combine(
        format.timestamp({
          format: 'YYYY-MM-DD HH:mm:ss.SSS'
        }),
        format.errors({ stack: true }),
        // Custom filter format for audit events only
        format((info) => {
          return info.audit_event ? info : false;
        })(),
        structuredFormat
      )
    })
  ],
  
  // Exception handling
  exceptionHandlers: [
    new DailyRotateFile({
      filename: path.join(logsDir, 'core-backend-exceptions-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '50m',
      maxFiles: '90d'
    })
  ],
  
  // Rejection handling (unhandled promise rejections)
  rejectionHandlers: [
    new DailyRotateFile({
      filename: path.join(logsDir, 'core-backend-rejections-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '50m',
      maxFiles: '90d'
    })
  ],
  
  // Don't exit on handled exceptions
  exitOnError: false
});

/**
 * Enhanced logger interface with compliance support
 * Provides methods for structured, compliant logging
 */
class NuclearLogger {
  private logger: Logger;
  
  constructor(logger: Logger) {
    this.logger = logger;
  }
  
  /**
   * Debug logging (development and troubleshooting)
   */
  debug(message: string, meta?: Partial<LogEntry>): void {
    this.log('debug', message, meta);
  }
  
  /**
   * Info logging (general operational information)
   */
  info(message: string, meta?: Partial<LogEntry>): void {
    this.log('info', message, meta);
  }
  
  /**
   * Warning logging (potential issues)
   */
  warn(message: string, meta?: Partial<LogEntry>): void {
    this.log('warn', message, meta);
  }
  
  /**
   * Error logging (errors and failures)
   */
  error(message: string, meta?: Partial<LogEntry>): void {
    this.log('error', message, meta);
  }
  
  /**
   * Audit logging (compliance and security events)
   */
  audit(auditEvent: string, message: string, meta?: Partial<LogEntry>): void {
    this.log('info', message, {
      ...meta,
      audit_event: auditEvent,
      classification: meta?.classification || 'HIGH'
    });
  }
  
  /**
   * Security logging (security-relevant events)
   */
  security(message: string, meta?: Partial<LogEntry>): void {
    this.log('warn', message, {
      ...meta,
      classification: 'CRITICAL',
      audit_event: meta?.audit_event || 'SECURITY_EVENT'
    });
  }
  
  /**
   * Compliance logging (regulatory compliance events)
   */
  compliance(message: string, meta?: Partial<LogEntry>): void {
    this.log('info', message, {
      ...meta,
      classification: 'CONFIDENTIAL',
      audit_event: meta?.audit_event || 'COMPLIANCE_EVENT'
    });
  }
  
  /**
   * Core logging method with classification-based level adjustment
   */
  private log(level: string, message: string, meta?: Partial<LogEntry>): void {
    const classification = meta?.classification || 'INTERNAL';
    
    // Adjust log level based on classification
    const adjustedLevel = CLASSIFICATION_LEVELS[classification] || level;
    
    // Add timestamp if not present
    const enhancedMeta = {
      ...meta,
      classification,
      timestamp: new Date().toISOString()
    };
    
    this.logger.log(adjustedLevel, message, enhancedMeta);
  }
  
  /**
   * Create child logger with default metadata
   */
  child(defaultMeta: Partial<LogEntry>): NuclearLogger {
    const childLogger = this.logger.child(defaultMeta);
    return new NuclearLogger(childLogger);
  }
}

// Create and export nuclear logger instance
const logger = new NuclearLogger(nuclearLogger);

// Log successful initialization
logger.info('üöÄ Nuclear logger initialized', {
  classification: 'INTERNAL',
  audit_event: 'LOGGER_INITIALIZED',
  log_level: getLogLevel(),
  environment: process.env.NODE_ENV || 'development',
  logs_directory: logsDir
});

export default logger;
// src/config/users.json
{
    "admin": {
      "password": "$2a$12$XovTOF4pkAY7RgW2VabJceEgNQPk.TjDmWxbwno5fWaL2wgHmBwjy", 
      "role": "admin"
    }
  }
  
// src/schemas/logPayload.schema.json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Log Payload Schema",
    "description": "Nuclear log ingestion payload schema with ISO 27001 A.8.2.1 compliance",
    "type": "object",
    "required": [
      "timestamp",
      "level",
      "message",
      "classification",
      "tenant_name"
    ],
    "properties": {
      "timestamp": {
        "type": "string",
        "format": "date-time",
        "description": "ISO 8601 timestamp of the log event"
      },
      "level": {
        "type": "string",
        "enum": ["debug", "info", "warn", "error", "fatal"],
        "description": "Log severity level"
      },
      "message": {
        "type": "string",
        "minLength": 1,
        "maxLength": 10000,
        "description": "Primary log message content"
      },
      "classification": {
        "type": "string",
        "enum": ["public", "internal", "confidential", "restricted"],
        "description": "Information classification level per ISO 27001 A.8.2.1",
        "default": "internal"
      },
      "tenant_name": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9_-]+$",
        "minLength": 1,
        "maxLength": 64,
        "description": "Multi-tenant identifier for data segregation"
      },
      "service_name": {
        "type": "string",
        "description": "Name of the service generating the log"
      },
      "correlation_id": {
        "type": "string",
        "description": "Request correlation identifier for tracing"
      },
      "user_id": {
        "type": "string",
        "description": "User identifier (if applicable)"
      },
      "session_id": {
        "type": "string",
        "description": "Session identifier (if applicable)"
      },
      "event_type": {
        "type": "string",
        "description": "Type of event being logged"
      },
      "metadata": {
        "type": "object",
        "description": "Additional structured metadata",
        "additionalProperties": true
      },
      "tags": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Array of tags for categorization"
      },
      "source": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "description": "Source file name"
          },
          "line": {
            "type": "integer",
            "description": "Source line number"
          },
          "function": {
            "type": "string",
            "description": "Source function name"
          }
        },
        "description": "Source code location information"
      },
      "request": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
          },
          "url": {
            "type": "string"
          },
          "ip": {
            "type": "string"
          },
          "user_agent": {
            "type": "string"
          }
        },
        "description": "HTTP request information (if applicable)"
      },
      "performance": {
        "type": "object",
        "properties": {
          "duration_ms": {
            "type": "number",
            "minimum": 0
          },
          "memory_usage": {
            "type": "number",
            "minimum": 0
          },
          "cpu_usage": {
            "type": "number",
            "minimum": 0,
            "maximum": 100
          }
        },
        "description": "Performance metrics"
      },
      "error": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "stack": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "description": "Error information (if applicable)"
      }
    },
    "additionalProperties": false
  }
